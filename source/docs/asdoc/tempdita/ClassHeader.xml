<?xml version="1.0" encoding="UTF-8"?>
<allClasses>
   <apiPackage id="org.as3collections.errors">
      <apiName>org.as3collections.errors</apiName>
      <apiDetail/>
      <apiClassifier id="org.as3collections.errors:IndexOutOfBoundsError">
         <apiName>IndexOutOfBoundsError</apiName>
         <shortdesc>
	 The error that is thrown to indicate that an index of some sort (such as to an array) is out of range.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="IndexOutOfBoundsError,org.as3collections.errors.IndexOutOfBoundsError"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>Error</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 The error that is thrown to indicate that an index of some sort (such as to an array) is out of range.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Error"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections.errors:ConcurrentModificationError">
         <apiName>ConcurrentModificationError</apiName>
         <shortdesc>
	 The error that is thrown by methods that have detected concurrent modification of an object when such modification is not permissible.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ConcurrentModificationError,org.as3collections.errors.ConcurrentModificationError"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>Error</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 The error that is thrown by methods that have detected concurrent modification of an object when such modification is not permissible.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Error"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections.errors:NoSuchElementError">
         <apiName>NoSuchElementError</apiName>
         <shortdesc>
	 The error that is thrown to indicate that there are no more elements in the iteration.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="NoSuchElementError,org.as3collections.errors.NoSuchElementError"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>Error</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 The error that is thrown to indicate that there are no more elements in the iteration.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Error"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
   </apiPackage>
   <apiPackage id="org.as3collections.iterators">
      <apiName>org.as3collections.iterators</apiName>
      <apiDetail/>
      <apiClassifier id="org.as3collections.iterators:ReadOnlyListIterator">
         <apiName>ReadOnlyListIterator</apiName>
         <shortdesc>
	 An iterator to iterate over lists.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ReadOnlyListIterator,org.as3collections.iterators.ReadOnlyListIterator,add,add,hasNext,hasNext,hasNext,hasNext,hasPrevious,hasPrevious,next,next,next,next,nextIndex,nextIndex,pointer,pointer,pointer,pointer,previous,previous,previousIndex,previousIndex,put,remove,remove,remove,remove,remove,remove,remove,reset,reset,reset,reset,set,set,set"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>org.as3collections.iterators:ListIterator</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 An iterator to iterate over lists.
	 This implementation doesn't allow modifications in the list.
	 All methods that change the list will throw an <codeph>UnsupportedOperationError</codeph>.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections.iterators:ListIterator"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections.iterators:ReadOnlyArrayIterator">
         <apiName>ReadOnlyArrayIterator</apiName>
         <shortdesc>
	 An iterator to iterate over an Array object.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ReadOnlyArrayIterator,org.as3collections.iterators.ReadOnlyArrayIterator,add,add,hasNext,hasNext,hasNext,hasNext,hasPrevious,hasPrevious,next,next,next,next,nextIndex,nextIndex,pointer,pointer,pointer,pointer,previous,previous,previousIndex,previousIndex,put,remove,remove,remove,remove,remove,remove,remove,reset,reset,reset,reset,set,set,set"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>org.as3collections.iterators:ArrayIterator</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 An iterator to iterate over an <codeph>Array</codeph> object.
	 This implementation doesn't allow modifications in the collection.
	 All methods that change the collection will throw an <codeph>UnsupportedOperationError</codeph>.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections.iterators:ArrayIterator"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections.iterators:ListIterator">
         <apiName>ListIterator</apiName>
         <shortdesc>
	 An iterator to iterate over lists (implementations of the IList interface).</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ListIterator,org.as3collections.iterators.ListIterator,add,add,hasNext,hasNext,hasNext,hasNext,hasPrevious,hasPrevious,next,next,next,next,nextIndex,nextIndex,pointer,pointer,pointer,pointer,previous,previous,previousIndex,previousIndex,put,remove,remove,remove,remove,remove,remove,remove,reset,reset,reset,reset,set,set,set"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IListIterator</apiBaseInterface>
               <apiBaseClassifier>Object</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 An iterator to iterate over lists (implementations of the <codeph>IList</codeph> interface).
	 <codeph>ListIterator</codeph> allows to traverse the list in either direction.
	 <p>
                  <b>IMPORTANT:</b>
               </p>
	              <p>A <codeph>ListIterator</codeph> has no current element; its cursor position always lies between the element that would be returned by a call to <codeph>previous()</codeph> and the element that would be returned by a call to <codeph>next()</codeph>.
	 An iterator for a list of length <codeph>n</codeph> has <codeph>n+1</codeph> possible cursor positions, as illustrated by the carets (^) below:</p>
	              <p>                                
	 Element(0)       
	 Element(1)       
	 Element(2)       
	 ... Element(n-1)</p>
	              <p>cursor positions:
	    
	 ^                    
	 ^                     
	 ^                    
	 ^                            
	 ^</p>
	              <p>Note that the <codeph>remove()</codeph> and <codeph>set()</codeph> methods are <i>not</i> defined in terms of the cursor position; they are defined to operate on the last element returned by a call to <codeph>next()</codeph> or <codeph>previous()</codeph>.</p>
	              <p>For further information do not hesitate to see the examples at the end of the page.</p>
	              <p>This documentation is partially based in the <i>Java Collections Framework</i> JavaDoc documentation.
	 For further information see <xref href="http://download.oracle.com/javase/6/docs/technotes/guides/collections/index.html"
                        scope="external">Java Collections Framework</xref>
               </p>
	 
	           </apiDesc>
            <example>
	 
	              <b>Example 1</b>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IList;
	 import org.as3collections.IListIterator;
	 import org.as3collections.lists.ArrayList;
	 
	 var list1:IList = new ArrayList([1, 3, 5]);
	 
	 list1                             // [1,3,5]
	 
	 var it:IListIterator = list1.listIterator();
	 var e:int;
	 
	 while (it.hasNext())
	 {
	 
	     ITERATION N.1
	 
	     it.pointer()                  // -1
	     it.nextIndex()                // 0
	     it.previousIndex()            // -1
	 
	     e = it.next();
	     e                             // 1
	 
	     it.pointer()                  // 0
	     it.nextIndex()                // 1
	     it.previousIndex()            // 0
	 
	     ITERATION N.2
	 
	     it.pointer()                  // 0
	     it.nextIndex()                // 1
	     it.previousIndex()            // 0
	 
	     e = it.next();
	     e                             // 3
	 
	     it.pointer()                  // 1
	     it.nextIndex()                // 2
	     it.previousIndex()            // 1
	 
	     if (e == 3)
	     {
	         //list1.add(4)            // ConcurrentModificationError: During the iteration, the list was changed directly (without use the iterator).
	         it.add(4);
	         list1                     // [1,3,4,5]
	     }
	 
	     ITERATION N.3
	 
	     it.pointer()                  // 2
	     it.nextIndex()                // 3
	     it.previousIndex()            // 2
	 
	     e = it.next();
	     e                             // 5
	 
	     it.pointer()                  // 3
	     it.nextIndex()                // 4
	     it.previousIndex()            // 3
	 
	     if (e == 5)
	     {
	         it.remove();
	         list1                     // [1,3,4]
	     }
	 }
	 </codeblock>
	 
	              <b>Example 2</b>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IList;
	 import org.as3collections.IListIterator;
	 import org.as3collections.lists.ArrayList;
	 
	 var list1:IList = new ArrayList([1, 3, 5]);
	 
	 list1                             // [1,3,5]
	 
	 var it:IListIterator = list1.listIterator(list1.size());
	 var e:int;
	 
	 while (it.hasPrevious())
	 
	 {
	 
	     ITERATION N.1
	 
	     it.pointer()                  // 2
	     it.nextIndex()                // 3
	     it.previousIndex()            // 2
	 
	     e = it.previous();
	     e                             // 5
	 
	     it.pointer()                  // 1
	     it.nextIndex()                // 2
	     it.previousIndex()            // 1
	 
	     if (e == 5)
	     {
	         it.remove()
	         list1                     // [1,3]
	     }
	 
	     ITERATION N.2
	 
	     it.pointer()                  // 1
	     it.nextIndex()                // 2
	     it.previousIndex()            // 1
	 
	     e = it.previous();
	     e                             // 3
	 
	     it.pointer()                  // 0
	     it.nextIndex()                // 1
	     it.previousIndex()            // 0
	 
	     if (e == 3)
	     {
	         //list1.add(4)            // ConcurrentModificationError: During the iteration, the list was changed directly (without use the iterator).
	         it.add(4);
	         list1                     // [1,4,3]
	     }
	 
	     ITERATION N.3
	 
	     it.pointer()                  // 1
	     it.nextIndex()                // 2
	     it.previousIndex()            // 1
	 
	     e = it.previous();
	     e                             // 4
	 
	     it.pointer()                  // 0
	     it.nextIndex()                // 1
	     it.previousIndex()            // 0
	 
	     ITERATION N.4
	 
	     it.pointer()                  // 0
	     it.nextIndex()                // 1
	     it.previousIndex()            // 0
	 
	     e = it.previous();
	     e                             // 1
	 
	     it.pointer()                  // -1
	     it.nextIndex()                // 0
	     it.previousIndex()            // -1
	 }
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IListIterator"/>
               </Implements>
               <Subclasses>
                  <class id="org.as3collections.iterators:ReadOnlyListIterator"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections.iterators:MapIterator">
         <apiName>MapIterator</apiName>
         <shortdesc>
	 An iterator to iterate over maps (implementations of the IMap interface).</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="MapIterator,org.as3collections.iterators.MapIterator,add,add,hasNext,hasNext,hasNext,hasNext,hasPrevious,hasPrevious,next,next,next,next,nextIndex,nextIndex,pointer,pointer,pointer,pointer,previous,previous,previousIndex,previousIndex,put,remove,remove,remove,remove,remove,remove,remove,reset,reset,reset,reset,set,set,set"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IIterator</apiBaseInterface>
               <apiBaseClassifier>Object</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 An iterator to iterate over maps (implementations of the <codeph>IMap</codeph> interface).
	 
	 </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IIterator;
	 import org.as3collections.IMap;
	 import org.as3collections.maps.ArrayListMap;
	 
	 var map1:IMap = new ArrayListMap();
	 map1.put("element-1", 1);
	 map1.put("element-3", 3);
	 map1.put("element-5", 5);
	 map1.put("element-7", 7);
	 
	 map1                             // ["element-1"=1,"element-3"=3,"element-5"=5,"element-7"=7]
	 
	 var it:IIterator = map1.iterator();
	 var e:int;
	 
	 while (it.hasNext())
	 {
	     ITERATION N.1
	 
	     it.pointer()                  // null
	 
	     e = it.next();
	     e                             // 1
	 
	     it.pointer()                  // "element-1"
	 
	     ITERATION N.2
	 
	     it.pointer()                  // "element-1"
	 
	     e = it.next();
	     e                             // 3
	 
	     it.pointer()                  // "element-3"
	 
	     if (e == 3)
	     {
	         it.remove();
	         map1                      // ["element-1"=1,"element-5"=5,"element-7"=7]
	     }
	 
	     ITERATION N.3
	 
	     it.pointer()                  // "element-1"
	 
	     e = it.next();
	     e                             // 5
	 
	     it.pointer()                  // "element-5"
	 
	     ITERATION N.4
	 
	     it.pointer()                  // "element-5"
	 
	     e = it.next();
	     e                             // 7
	 
	     it.pointer()                  // "element-7"
	 }
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IIterator"/>
               </Implements>
               <Subclasses>
                  <class id="org.as3collections.iterators:ReadOnlyMapIterator"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections.iterators:ArrayIterator">
         <apiName>ArrayIterator</apiName>
         <shortdesc>
	 An iterator to iterate over an Array object.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ArrayIterator,org.as3collections.iterators.ArrayIterator,add,add,hasNext,hasNext,hasNext,hasNext,hasPrevious,hasPrevious,next,next,next,next,nextIndex,nextIndex,pointer,pointer,pointer,pointer,previous,previous,previousIndex,previousIndex,put,remove,remove,remove,remove,remove,remove,remove,reset,reset,reset,reset,set,set,set"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IIterator</apiBaseInterface>
               <apiBaseClassifier>Object</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 An iterator to iterate over an <codeph>Array</codeph> object.
	 
	 </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IIterator;
	 import org.as3collections.IList;
	 import org.as3collections.lists.ArrayList;
	 
	 var list1:IList = new ArrayList([1, 3, 5, 7]);
	 
	 list1                             // [1,3,5,7]
	 
	 var it:IIterator = list1.iterator();
	 var e:int;
	 
	 while (it.hasNext())
	 {
	     ITERATION N.1
	 
	     it.pointer()                  // -1
	 
	     e = it.next();
	     e                             // 1
	 
	     it.pointer()                  // 0
	 
	     ITERATION N.2
	 
	     it.pointer()                  // 0
	 
	     e = it.next();
	     e                             // 3
	 
	     it.pointer()                  // 1
	 
	     if (e == 3)
	     {
	         it.remove();
	         list1                     // [1,5,7]
	     }
	 
	     ITERATION N.3
	 
	     it.pointer()                  // 0
	 
	     e = it.next();
	     e                             // 5
	 
	     it.pointer()                  // 1
	 
	     ITERATION N.4
	 
	     it.pointer()                  // 1
	 
	     e = it.next();
	     e                             // 7
	 
	     it.pointer()                  // 2
	 }
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IIterator"/>
               </Implements>
               <Subclasses>
                  <class id="org.as3collections.iterators:ReadOnlyArrayIterator"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections.iterators:ListMapIterator">
         <apiName>ListMapIterator</apiName>
         <shortdesc>
	 An iterator to iterate over implementations of IListMap interface.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ListMapIterator,org.as3collections.iterators.ListMapIterator,add,add,hasNext,hasNext,hasNext,hasNext,hasPrevious,hasPrevious,next,next,next,next,nextIndex,nextIndex,pointer,pointer,pointer,pointer,previous,previous,previousIndex,previousIndex,put,remove,remove,remove,remove,remove,remove,remove,reset,reset,reset,reset,set,set,set"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IListMapIterator</apiBaseInterface>
               <apiBaseClassifier>Object</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 An iterator to iterate over implementations of <codeph>IListMap</codeph> interface.
	 <codeph>ListMapIterator</codeph> allows to traverse the map in either direction.
	 <p>
                  <b>IMPORTANT:</b>
               </p>
	              <p>A <codeph>ListMapIterator</codeph> has no current mapping; its cursor position always lies between the mapping that would be returned by a call to <codeph>previous()</codeph> and the mapping that would be returned by a call to <codeph>next()</codeph>.
	 An iterator for a map of length <codeph>n</codeph> has <codeph>n+1</codeph> possible cursor positions, as illustrated by the carets (^) below:</p>
	              <p>                                
	 Element(0)       
	 Element(1)       
	 Element(2)       
	 ... Element(n-1)</p>
	              <p>cursor positions:
	    
	 ^                    
	 ^                     
	 ^                    
	 ^                            
	 ^</p>
	              <p>Note that the <codeph>remove()</codeph> and <codeph>set()</codeph> methods are <i>not</i> defined in terms of the cursor position; they are defined to operate on the last mapping returned by a call to <codeph>next()</codeph> or <codeph>previous()</codeph>.</p>
	              <p>For further information do not hesitate to see the examples at the end of the page.</p>
	              <p>This documentation is partially based in the <i>Java Collections Framework</i> JavaDoc documentation.
	 For further information see <xref href="http://download.oracle.com/javase/6/docs/technotes/guides/collections/index.html"
                        scope="external">Java Collections Framework</xref>
               </p>
	 
	           </apiDesc>
            <example>
	 
	              <b>Example 1</b>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IListMap;
	 import org.as3collections.IListMapIterator;
	 import org.as3collections.maps.ArrayListMap;
	 
	 var map1:IListMap = new ArrayListMap();
	 map1.put("element-1", 1);
	 map1.put("element-3", 3);
	 map1.put("element-5", 5);
	 
	 map1                                // ["element-1"=1,"element-3"=3,"element-5"=5]
	 
	 var it:IListMapIterator = map1.listMapIterator();
	 var e:int;
	 
	 while (it.hasNext())
	 {
	 
	     ITERATION N.1
	 
	     it.pointer()                    // null
	     it.nextIndex()                  // 0
	     it.previousIndex()              // -1
	 
	     e = it.next();
	     e                               // 1
	 
	     it.pointer()                    // "element-1"
	     it.nextIndex()                  // 1
	     it.previousIndex()              // 0
	 
	     ITERATION N.2
	 
	     it.pointer()                    // "element-1"
	     it.nextIndex()                  // 1
	     it.previousIndex()              // 0
	 
	     e = it.next();
	     e                               // 3
	 
	     it.pointer()                    // "element-3"
	     it.nextIndex()                  // 2
	     it.previousIndex()              // 1
	 
	     if (e == 3)
	     {
	         //map1.put("element-4", 4)  // ConcurrentModificationError: During the iteration, the map was changed directly (without use the iterator).
	         it.put("element-4", 4);
	         map1                        // ["element-1"=1,"element-3"=3,"element-4"=4,"element-5"=5]
	     }
	 
	     ITERATION N.3
	 
	     it.pointer()                    // "element-4"
	     it.nextIndex()                  // 3
	     it.previousIndex()              // 2
	 
	     e = it.next();
	     e                               // 5
	 
	     it.pointer()                    // "element-5"
	     it.nextIndex()                  // 4
	     it.previousIndex()              // 3
	 
	     if (e == 5)
	     {
	         it.remove();
	         map1                        // ["element-1"=1,"element-3"=3,"element-4"=4]
	     }
	 }
	 </codeblock>
	 
	              <b>Example 2</b>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IListMap;
	 import org.as3collections.IListMapIterator;
	 import org.as3collections.maps.ArrayListMap;
	 
	 var map1:IListMap = new ArrayListMap();
	 map1.put("element-1", 1);
	 map1.put("element-3", 3);
	 map1.put("element-5", 5);
	 
	 map1                                // ["element-1"=1,"element-3"=3,"element-5"=5]
	 
	 var it:IListMapIterator = map1.listIterator(map1.size());
	 var e:int;
	 
	 while (it.hasPrevious())
	 
	 {
	 
	     ITERATION N.1
	 
	     it.pointer()                    // "element-5"
	     it.nextIndex()                  // 3
	     it.previousIndex()              // 2
	 
	     e = it.previous();
	     e                               // 5
	 
	     it.pointer()                    // "element-3"
	     it.nextIndex()                  // 2
	     it.previousIndex()              // 1
	 
	     if (e == 5)
	     {
	         it.remove()
	         map1                        // ["element-1"=1,"element-3"=3]
	     }
	 
	     ITERATION N.2
	 
	     it.pointer()                    // "element-3"
	     it.nextIndex()                  // 2
	     it.previousIndex()              // 1
	 
	     e = it.previous();
	     e                               // 3
	 
	     it.pointer()                    // "element-1"
	     it.nextIndex()                  // 1
	     it.previousIndex()              // 0
	 
	     if (e == 3)
	     {
	         //map1.put("element-4", 4); // ConcurrentModificationError: During the iteration, the map was changed directly (without use the iterator).
	         it.put("element-4", 4);
	         map1                        // [1,4,3]
	     }
	 
	     ITERATION N.3
	 
	     it.pointer()                    // "element-3"
	     it.nextIndex()                  // 2
	     it.previousIndex()              // 1
	 
	     e = it.previous();
	     e                               // 4
	 
	     it.pointer()                    // "element-1"
	     it.nextIndex()                  // 1
	     it.previousIndex()              // 0
	 
	     ITERATION N.4
	 
	     it.pointer()                    // "element-1"
	     it.nextIndex()                  // 1
	     it.previousIndex()              // 0
	 
	     e = it.previous();
	     e                               // 1
	 
	     it.pointer()                    // null
	     it.nextIndex()                  // 0
	     it.previousIndex()              // -1
	 }
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IListMapIterator"/>
               </Implements>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections.iterators:ReadOnlyMapIterator">
         <apiName>ReadOnlyMapIterator</apiName>
         <shortdesc>
	 An iterator to iterate over maps (implementations of the IMap interface).</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ReadOnlyMapIterator,org.as3collections.iterators.ReadOnlyMapIterator,add,add,hasNext,hasNext,hasNext,hasNext,hasPrevious,hasPrevious,next,next,next,next,nextIndex,nextIndex,pointer,pointer,pointer,pointer,previous,previous,previousIndex,previousIndex,put,remove,remove,remove,remove,remove,remove,remove,reset,reset,reset,reset,set,set,set"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>org.as3collections.iterators:MapIterator</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 An iterator to iterate over maps (implementations of the <codeph>IMap</codeph> interface).
	 This implementation doesn't allow modifications in the map.
	 All methods that change the map will throw an <codeph>UnsupportedOperationError</codeph>.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections.iterators:MapIterator"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
   </apiPackage>
   <apiPackage id="org.as3collections.lists">
      <apiName>org.as3collections.lists</apiName>
      <apiDetail/>
      <apiClassifier id="org.as3collections.lists:UniqueList">
         <apiName>UniqueList</apiName>
         <shortdesc>
	 UniqueList works as a wrapper for a IList object.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="UniqueList,org.as3collections.lists.UniqueList,comparator,comparator,comparator,modCount,modCount,options,options,options,add,addAll,addAllAt,addAllAt,addAllAt,addAt,addAt,addAt,addAt,addAt,clear,clear,clone,clone,clone,clone,clone,clone,clone,ensureCapacity,equals,equals,equals,equals,equals,getAt,getAt,indexOf,indexOf,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listIterator,listIterator,remove,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,retainAll,reverse,reverse,reverse,reverse,setAt,setAt,setAt,setAt,setAt,sort,sort,sort,sortOn,sortOn,sortOn,subList,subList,subList,subList,subList,subList,subList"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IList</apiBaseInterface>
               <apiBaseClassifier>org.as3collections:UniqueCollection</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	              <codeph>UniqueList</codeph> works as a wrapper for a <codeph>IList</codeph> object.
	 It does not allow duplicated elements in the collection.
	 It stores the <codeph>wrapList</codeph> constructor's argument in the <codeph>wrappedList</codeph> variable.
	 So every method call to this class is forwarded to the <codeph>wrappedList</codeph> object.
	 The methods that need to be checked for duplication are previously validated before forward the call.
	 No error is thrown by the validation of duplication.
	 The calls that are forwarded to the <codeph>wrappedList</codeph> returns the return of the <codeph>wrappedList</codeph> call.
	 <p>You can also create unique and typed lists. See below the link "ListUtil.getUniqueTypedList()".</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IList;
	 import org.as3collections.IListIterator;
	 import org.as3collections.lists.ArrayList;
	 import org.as3collections.lists.UniqueList;
	 import org.as3collections.utils.ListUtil;
	 
	 var l1:IList = new ArrayList([3, 5, 1, 7]);
	 
	 var list1:IList = new UniqueList(l1); // you can use this way
	 
	 //var list1:IList = ListUtil.getUniqueList(l1); // or you can use this way
	 
	 list1                       // [3,5,1,7]
	 list1.size()                // 4
	 
	 list1.addAt(1, 4)           // true
	 list1                       // [3,4,5,1,7]
	 list1.size()                // 5
	 
	 list1.addAt(2, 3)           // false
	 list1                       // [3,4,5,1,7]
	 list1.size()                // 5
	 
	 list1.add(5)                // false
	 list1                       // [3,4,5,1,7]
	 list1.size()                // 5
	 
	 var it:IListIterator = list1.listIterator();
	 var e:int;
	 
	 while (it.hasNext())
	 {
	 
	     e = it.next()
	     e                       // 3
	 
	     e = it.next()
	     e                       // 4
	 
	     e = it.next()
	     e                       // 5
	 
	     if (e == 5)
	     {
	         it.add(0)
	 
	         list1               // [3,4,5,0,1,7]
	         list1.size()        // 6
	     }
	 
	     e = it.next()
	     e                       // 1
	 
	     if (e == 1)
	     {
	         it.add(3)
	 
	         list1               // [3,4,5,0,1,7]
	         list1.size()        // 6
	     }
	 
	     e = it.next()
	     e                       // 7
	 }
	 
	 list1                       // [3,4,5,0,1,7]
	 list1.size()                // 6
	 
	 var l2:IList = new ArrayList([1, 2, 3, 4, 5, 1, 3, 5]);
	 
	 var list2:IList = new UniqueList(l2); // you can use this way
	 
	 //var list2:IList = ListUtil.getUniqueList(l2); // or you can use this way
	 
	 list2                       // [1,2,3,4,5]
	 list2.size()                // 5
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections:UniqueCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IList"/>
               </Implements>
               <Subclasses>
                  <class id="org.as3collections.lists:UniqueSortedList"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.utils.xml#ListUtil/getUniqueList()">
               <linktext>ListUtil.getUniqueList()</linktext>
            </link>
            <link href="org.as3collections.utils.xml#ListUtil/getUniqueTypedList()">
               <linktext>ListUtil.getUniqueTypedList()</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.lists:TypedList">
         <apiName>TypedList</apiName>
         <shortdesc>
	 TypedList works as a wrapper for a IList object.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="TypedList,org.as3collections.lists.TypedList,comparator,comparator,comparator,modCount,modCount,options,options,options,add,addAll,addAllAt,addAllAt,addAllAt,addAt,addAt,addAt,addAt,addAt,clear,clear,clone,clone,clone,clone,clone,clone,clone,ensureCapacity,equals,equals,equals,equals,equals,getAt,getAt,indexOf,indexOf,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listIterator,listIterator,remove,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,retainAll,reverse,reverse,reverse,reverse,setAt,setAt,setAt,setAt,setAt,sort,sort,sort,sortOn,sortOn,sortOn,subList,subList,subList,subList,subList,subList,subList"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IList</apiBaseInterface>
               <apiBaseClassifier>org.as3collections:TypedCollection</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	              <codeph>TypedList</codeph> works as a wrapper for a <codeph>IList</codeph> object.
	 Since ActionScript 3.0 does not support typed arrays, <codeph>TypedList</codeph> is a way to create typed lists.
	 It stores the <codeph>wrapList</codeph> constructor's argument internaly.
	 So every method call to this class is forwarded to the <codeph>wrappedList</codeph> object.
	 The methods that need to be checked for the type of the elements are previously validated before forward the call.
	 If the type of an element requested to be added to this list is incompatible with the type of the list a <codeph>org.as3coreaddendum.errors.ClassCastError</codeph> is thrown.
	 The calls that are forwarded to the <codeph>wrappedList</codeph> returns the return of the <codeph>wrappedList</codeph> call.
	 <p>
                  <codeph>TypedList</codeph> does not allow <codeph>null</codeph> elements.</p>
	              <p>You can also create unique and typed lists. See below the link "ListUtil.getUniqueTypedList()".</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IList;
	 import org.as3collections.IListIterator;
	 import org.as3collections.lists.ArrayList;
	 import org.as3collections.lists.TypedList;
	 import org.as3collections.utils.ListUtil;
	 
	 var l1:IList = new ArrayList([3, 5, 1, 7]);
	 
	 var list1:IList = new TypedList(l1, int); // you can use this way
	 
	 //var list1:IList = ListUtil.getTypedList(l1, int); // or you can use this way
	 
	 list1                          // [3,5,1,7]
	 list1.size()                   // 4
	 
	 list1.add(8)                   // true
	 list1                          // [3,5,1,7,8]
	 list1.size()                   // 5
	 
	 list1.addAt(1, 4)              // true
	 list1                          // [3,4,5,1,7,8]
	 list1.size()                   // 6
	 
	 list1.remove("abc")            // false
	 list1                          // [3,4,5,1,7,8]
	 list1.size()                   // 6
	 
	 var it:IListIterator = list1.listIterator();
	 var e:int;
	 
	 while (it.hasNext())
	 {
	 
	     e = it.next()
	     e                          // 3
	 
	     e = it.next()
	     e:                         // 4
	 
	     e = it.next()
	     e                          // 5
	 
	     if (e == 5)
	     {
	         it.add(0)
	 
	         list1                  // [3,4,5,0,1,7,8]
	         list1.size()           // 7
	     }
	 
	     e = it.next()
	     e                          // 1
	 
	     if (e == 1)
	     {
	         it.add(3)
	 
	         list1                  // [3,4,5,0,1,3,7,8]
	         list1.size()           // 8
	     }
	 
	     e = it.next()
	     e                          // 7
	 
	     e = it.next()
	     e                          // 8
	 
	     if (e == 8)
	     {
	         it.add("ghi")          // ClassCastError: Invalid element type. element: ghi | type: String | expected type: int
	     }
	 }
	 
	 list1                          // [3,4,5,0,1,3,7,8]
	 list1.size()                   // 8
	 
	 list1.add("def")               // ClassCastError: Invalid element type. element: def | type: String | expected type: int
	 
	 list1.setAt(0, 1)              // 3
	 list1                          // [1,4,5,0,1,3,7,8]
	 list1.size()                   // 8
	 
	 list1.setAt(0, [1,2])          // ClassCastError: Invalid element type. element: 1,2 | type: Array | expected type: int
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections:TypedCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IList"/>
               </Implements>
               <Subclasses>
                  <class id="org.as3collections.lists:TypedSortedList"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.utils.xml#ListUtil/getTypedList()">
               <linktext>ListUtil.getTypedList()</linktext>
            </link>
            <link href="org.as3collections.utils.xml#ListUtil/getUniqueTypedList()">
               <linktext>ListUtil.getUniqueTypedList()</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.lists:ReadOnlyArrayList">
         <apiName>ReadOnlyArrayList</apiName>
         <shortdesc>
	 A list that does not allow modifications.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ReadOnlyArrayList,org.as3collections.lists.ReadOnlyArrayList,add,addAll,addAllAt,addAllAt,addAllAt,addAt,addAt,addAt,addAt,addAt,clear,clear,clone,clone,clone,clone,clone,clone,clone,ensureCapacity,equals,equals,equals,equals,equals,getAt,getAt,indexOf,indexOf,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listIterator,listIterator,remove,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,retainAll,reverse,reverse,reverse,reverse,setAt,setAt,setAt,setAt,setAt,sort,sort,sort,sortOn,sortOn,sortOn,subList,subList,subList,subList,subList,subList,subList"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>org.as3collections:AbstractList</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 A list that does not allow modifications.
	 It receives all the elements by its constructor and can no longer be changed.
	 All methods that change this list will throw an <codeph>org.as3coreaddendum.errors.UnsupportedOperationError</codeph>.
	 
	 </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IList;
	 import org.as3collections.lists.ArrayList;
	 import org.as3collections.lists.ReadOnlyArrayList;
	 
	 var list1:IList = new ArrayList([3, 5, 1, 7]);
	 
	 list1                       // [3,5,1,7]
	 
	 var list2:IList = new ReadOnlyArrayList(list1.toArray());
	 
	 list2                       // [3,5,1,7]
	 
	 list2.add(1)                // UnsupportedOperationError: ReadOnlyArrayList is a read-only list and doesn't allow modifications.
	 list2.remove(1)             // UnsupportedOperationError: ReadOnlyArrayList is a read-only list and doesn't allow modifications.
	 
	 var list3:IList = list2.clone();
	 
	 list3                       // [3,5,1,7]
	 
	 list3.contains(2)           // false
	 list3.contains(5)           // true
	 list3.indexOf(5)            // 1
	 list3.containsAll(list1)    // true
	 list3.equals(list1)         // false
	 list3.getAt(2)              // 1
	 list3.subList(1, 3)         // [5,1]
	 
	 list3.addAll(list2)         // UnsupportedOperationError: ReadOnlyArrayList is a read-only list and doesn't allow modifications.
	 list3.removeRange(1, 3)     // UnsupportedOperationError: ReadOnlyArrayList is a read-only list and doesn't allow modifications.
	 
	 var it:IIterator = list3.iterator();
	 
	 while (it.hasNext())
	 {
	     it.next()
	 
	     it.remove()             // UnsupportedOperationError: ReadOnlyArrayIterator is a read-only iterator and doesn't allow modifications in the collection.
	 }
	 
	 var it2:IListIterator = list3.listIterator();
	 
	 while (it2.hasNext())
	 {
	     it2.next()
	 
	     it.add(1)               // UnsupportedOperationError: ReadOnlyListIterator is a read-only iterator and doesn't allow modifications in the list.
	 }
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections:AbstractList"/>
                  <Inherit id="org.as3collections:AbstractArrayCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections.lists:UniqueSortedList">
         <apiName>UniqueSortedList</apiName>
         <shortdesc>
	 UniqueSortedList works as a wrapper for a ISortedList object.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="UniqueSortedList,org.as3collections.lists.UniqueSortedList,comparator,comparator,comparator,modCount,modCount,options,options,options,add,addAll,addAllAt,addAllAt,addAllAt,addAt,addAt,addAt,addAt,addAt,clear,clear,clone,clone,clone,clone,clone,clone,clone,ensureCapacity,equals,equals,equals,equals,equals,getAt,getAt,indexOf,indexOf,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listIterator,listIterator,remove,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,retainAll,reverse,reverse,reverse,reverse,setAt,setAt,setAt,setAt,setAt,sort,sort,sort,sortOn,sortOn,sortOn,subList,subList,subList,subList,subList,subList,subList"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:ISortedList</apiBaseInterface>
               <apiBaseClassifier>org.as3collections.lists:UniqueList</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	              <codeph>UniqueSortedList</codeph> works as a wrapper for a <codeph>ISortedList</codeph> object.
	 It does not allow duplicated elements in the collection.
	 It stores the <codeph>wrapList</codeph> constructor's argument in the <codeph>wrappedList</codeph> variable.
	 So every method call to this class is forwarded to the <codeph>wrappedList</codeph> object.
	 The methods that need to be checked for duplication are previously validated before forward the call.
	 No error is thrown by the validation of duplication.
	 The calls that are forwarded to the <codeph>wrappedList</codeph> returns the return of the <codeph>wrappedList</codeph> call.
	 <p>You can also create unique and typed sorted lists.
	 See below the link "ListUtil.getUniqueTypedSortedList()".</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.ISortedList;
	 import org.as3collections.IListIterator;
	 import org.as3collections.lists.SortedArrayList;
	 import org.as3collections.lists.UniqueSortedList;
	 import org.as3collections.utils.ListUtil;
	 
	 var l1:ISortedList = new SortedArrayList([3, 5, 1, 7], null, Array.NUMERIC);
	 
	 var list1:ISortedList = new UniqueSortedList(l1); // you can use this way
	 
	 //var list1:ISortedList = ListUtil.getUniqueSortedList(l1); // or you can use this way
	 
	 list1                       // [1,3,5,7]
	 list1.size()                // 4
	 
	 list1.addAt(1, 4)           // true
	 list1                       // [1,3,4,5,7]
	 list1.size()                // 5
	 
	 list1.addAt(2, 3)           // false
	 list1                       // [1,3,4,5,7]
	 list1.size()                // 5
	 
	 list1.add(5)                // false
	 list1                       // [1,3,4,5,7]
	 list1.size()                // 5
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections.lists:UniqueList"/>
                  <Inherit id="org.as3collections:UniqueCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:ISortedList"/>
               </Implements>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.utils.xml#ListUtil/getUniqueSortedList()">
               <linktext>ListUtil.getUniqueSortedList()</linktext>
            </link>
            <link href="org.as3collections.utils.xml#ListUtil/getUniqueTypedSortedList()">
               <linktext>ListUtil.getUniqueTypedSortedList()</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.lists:ArrayList">
         <apiName>ArrayList</apiName>
         <shortdesc>
	 Resizable-array implementation of the IList interface.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ArrayList,org.as3collections.lists.ArrayList,add,addAll,addAllAt,addAllAt,addAllAt,addAt,addAt,addAt,addAt,addAt,clear,clear,clone,clone,clone,clone,clone,clone,clone,ensureCapacity,equals,equals,equals,equals,equals,getAt,getAt,indexOf,indexOf,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listIterator,listIterator,remove,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,retainAll,reverse,reverse,reverse,reverse,setAt,setAt,setAt,setAt,setAt,sort,sort,sort,sortOn,sortOn,sortOn,subList,subList,subList,subList,subList,subList,subList"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>org.as3collections:AbstractList</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 Resizable-array implementation of the <codeph>IList</codeph> interface.
	 Implements all optional list operations, and permits all elements, including <codeph>null</codeph>.
	 <p>Each <codeph>ArrayList</codeph> instance has a capacity.
	 The capacity is the size of the array used to store the elements in the list.
	 It is always at least as large as the list size.
	 As elements are added to an <codeph>ArrayList</codeph> object, its capacity grows automatically.</p>
	              <p>In addition to implementing the <codeph>IList</codeph> interface, this class provides the <codeph>ensureCapacity</codeph> method to arbitrarily manipulate the size of the array (this usage is not common) that is used internally to store the elements.
	 Check the examples at the bottom of the page for further information about usage.</p>
	              <p>It's possible to create unique lists, typed lists and even unique typed lists.
	 You just send the <codeph>ArrayList</codeph> object to the wrappers <codeph>UniqueList</codeph> or <codeph>TypedList</codeph> or uses the <codeph>ListUtil.getUniqueList</codeph>, <codeph>ListUtil.getTypedList</codeph> or <codeph>ListUtil.getUniqueTypedList</codeph>.</p>
	              <p>This documentation is partially based in the <i>Java Collections Framework</i> JavaDoc documentation.
	 For further information see <xref href="http://download.oracle.com/javase/6/docs/technotes/guides/collections/index.html"
                        scope="external">Java Collections Framework</xref>
               </p>
	 
	           </apiDesc>
            <example>
	 
	              <b>Example 1</b>
	              <codeblock rev="3.0">
	 import org.as3collections.IList;
	 import org.as3collections.lists.ArrayList;
	 
	 var list1:IList = new ArrayList();
	 
	 list1                           // []
	 
	 list1.size()                    // 0
	 list1.contains(null)            // false
	 list1.contains("abc")           // false
	 list1.isEmpty()                 // true
	 list1.modCount                  // 0
	 
	 list1.clear()
	 
	 list1.modCount                  // 0
	 list1.isEmpty()                 // true
	 list1.size()                    // 0
	 
	 list1.add(null)                 // true
	 list1                           // [null]
	 list1.isEmpty()                 // false
	 list1.size()                    // 1
	 list1.modCount                  // 1
	 list1.contains(null)            // true
	 list1.contains("abc")           // false
	 
	 list1.add("abc")                // true
	 list1                           // [null,abc]
	 list1.size()                    // 2
	 list1.modCount                  // 2
	 list1.contains("abc")           // true
	 
	 list1.add(null)                 // true
	 list1                           // [null,abc,null]
	 list1.size()                    // 3
	 list1.modCount                  // 3
	 list1.indexOf(null)             // 0
	 list1.lastIndexOf(null)         // 2
	 
	 list1.addAt(0, 123)             // true
	 list1                           // [123,null,abc,null]
	 list1.size()                    // 4
	 list1.modCount                  // 4
	 
	 list1.addAt(4, "def")           // true
	 list1                           // [123,null,abc,null,def]
	 list1.size()                    // 5
	 
	 list1.addAt(4, "abc")           // true
	 list1                           // [123,null,abc,null,abc,def]
	 list1.size()                    // 6
	 list1.modCount                  // 6
	 
	 list1.getAt(0)                  // 123
	 list1.getAt(2)                  // abc
	 list1.getAt(5)                  // def
	 
	 list1.removeAt(0)               // 123
	 list1                           // [null,abc,null,abc,def]
	 list1.size()                    // 5
	 list1.modCount                  // 7
	 
	 list1.removeAt(4)               // def
	 list1                           // [null,abc,null,abc]
	 list1.size()                    // 4
	 list1.modCount                  // 8
	 
	 list1.removeAt(0)               // null
	 list1                           // [abc,null,abc]
	 list1.size()                    // 3
	 list1.modCount                  // 9
	 
	 var list2:IList = list1.clone();
	 
	 list2                           // [abc,null,abc]
	 
	 list1.containsAll(list1)        // true
	 list1.containsAll(list2)        // true
	 list2.containsAll(list1)        // true
	 list1.equals(list2)             // true
	 
	 list2.remove("abc")             // true
	 list2.remove("abc")             // true
	 list2.add(null)                 // true
	 list2                           // [null,null]
	 
	 list1.containsAll(list2)        // true
	 list2.containsAll(list1)        // false
	 list1.equals(list2)             // false
	 
	 list1                           // [abc,null,abc]
	 list1.size()                    // 3
	 list1.setAt(2, "ghi")           // abc
	 list1                           // [abc,null,ghi]
	 list1.size()                    // 3
	 list1.modCount                  // 9
	 
	 list1.clear()
	 
	 list1.modCount                  // 10
	 list1.isEmpty()                 // true
	 list1.size()                    // 0
	 </codeblock>
	 
	              <b>Example 2</b>
	              <codeblock rev="3.0">
	 import org.as3collections.IList;
	 import org.as3collections.lists.ArrayList;
	 
	 var arr:Array = [1, 2, 3, 4];
	 var list1:IList = new ArrayList(arr);
	 
	 list1                                 // [1,2,3,4]
	 list1.size()                          // 4
	 list1.isEmpty()                       // false
	 list1.modCount                        // 0
	 
	 var list2:IList = new ArrayList([9, 10, 11, 12]);
	 
	 list2                                 // [9,10,11,12]
	 list2.size()                          // 4
	 list2.isEmpty()                       // false
	 list2.modCount                        // 0
	 
	 list1.addAll(list2)                   // true
	 list1                                 // [1,2,3,4,9,10,11,12]
	 list1.size()                          // 8
	 list1.modCount                        // 4
	 
	 var list3:IList = new ArrayList([5, 6, 7, 8]);
	 
	 list3                                 // [5,6,7,8]
	 list3.size()                          // 4
	 list3.isEmpty()                       // false
	 list3.modCount                        // 0
	 
	 list1.addAllAt(4, list3)              // true
	 list1                                 // [1,2,3,4,5,6,7,8,9,10,11,12]
	 list1.size()                          // 12
	 list1.modCount                        // 8
	 
	 list1.containsAll(list3)              // true
	 list3.containsAll(list1)              // false
	 
	 list1.removeAll(list3)                // true
	 list1                                 // [1,2,3,4,9,10,11,12]
	 list1.size()                          // 8
	 list1.modCount                        // 12
	 
	 list1.removeAll(list3)                // false
	 list1                                 // [1,2,3,4,9,10,11,12]
	 list1.size()                          // 8
	 list1.modCount                        // 12
	 
	 list1.retainAll(list2)                // true
	 list1                                 // [9,10,11,12]
	 list1.size()                          // 4
	 list1.modCount                        // 16
	 
	 list1.subList(0, 1)                   // [9]
	 list1.subList(0, 2)                   // [9,10]
	 list1.subList(0, 4)                   // [9,10,11,12]
	 list1.subList(0, list1.size())        // [9,10,11,12]
	 
	 list1.removeRange(1, 3)               // [10,11]
	 list1                                 // [9,12]
	 list1.size()                          // 2
	 list1.modCount                        // 17
	 
	 list1.remove(9)                       // true
	 list1                                 // [12]
	 list1.size()                          // 1
	 list1.modCount                        // 18
	 
	 list1.retainAll(list3)                // true
	 list1                                 // []
	 list1.size()                          // 0
	 list1.modCount                        // 19
	 </codeblock>
	 
	              <b>Example 3</b>
	              <codeblock rev="3.0">
	 import org.as3collections.IList;
	 import org.as3collections.lists.ArrayList;
	 
	 var list1:ArrayList = new ArrayList();
	 
	 list1                     // []
	 list1.addAt(3, 4)         // IndexOutOfBoundsError: The 'index' argument is out of bounds: 3 (min: 0, max: 0)
	 
	 list1.ensureCapacity(5)
	 
	 list1                     // [undefined,undefined,undefined,undefined,undefined]
	 list1.modCount            // 1
	 list1.isEmpty()           // false
	 list1.size()              // 5
	 
	 list1.addAt(3, 4)         // true
	 list1                     // [undefined,undefined,undefined,4,undefined,undefined]
	 list1.modCount            // 2
	 list1.size()              // 6
	 
	 list1.getAt(1)            // undefined
	 
	 list1.ensureCapacity(3)
	 
	 list1                     // [undefined,undefined,undefined,4,undefined,undefined]
	 list1.modCount            // 2
	 list1.size()              // 6
	 
	 list1.setAt(2, 3)         // undefined
	 list1                     // [undefined,undefined,3,4,undefined,undefined]
	 list1.modCount            // 2
	 list1.size()              // 6
	 
	 list1.remove(undefined)   // true
	 list1.remove(undefined)   // true
	 list1                     // [3,4,undefined,undefined]
	 list1.modCount            // 4
	 list1.size()              // 4
	 </codeblock>
	 
	              <b>Example 4 - Using equality (org.as3coreaddendum.system.IEquatable)</b>
	 
	              <codeblock rev="3.0">
	 package test
	 {
	     import org.as3coreaddendum.system.IEquatable;
	 
	     public class TestEquatableObject implements IEquatable
	     {
	         private var _id:String;
	 		
	         public function get id(): String { return _id; }
	 
	         public function set id(value:String): void { _id = value; }
	 
	         public function TestEquatableObject(id:String)
	         {
	             _id = id;
	         }
	 
	         public function equals(other:: Boolean
	         {
	             return other is TestEquatableObject &amp;&amp; _id == (other as TestEquatableObject).id;
	         }
	 
	         public function toString(): String
	         {
	             return "[TestEquatableObject " + _id + "]";
	         }
	     }
	 }
	 </codeblock>
	 
	              <codeblock rev="3.0">
	 import test.TestEquatableObject;
	 
	 import org.as3collections.IList;
	 import org.as3collections.lists.ArrayList;
	 import org.as3collections.lists.UniqueList;
	 
	 var list1:ArrayList = new ArrayList();
	 
	 list1                               // []
	 
	 var o1:TestEquatableObject = new TestEquatableObject("o1");
	 var o2:TestEquatableObject = new TestEquatableObject("o2");
	 var o3:TestEquatableObject = new TestEquatableObject("o3");
	 var o4:TestEquatableObject = new TestEquatableObject("o4");
	 
	 list1.contains(o1)                  // false
	 list1.add(o1)                       // true
	 list1                               // [[TestEquatableObject o1]]
	 list1.contains(o1)                  // true
	 
	 var o5:TestEquatableObject = new TestIndexablePriority("o1"); // -&gt; Attention to the id, which is "o1"
	 
	 list1.contains(o5)                  // true -&gt; without equality would return false, because o1 and o5 are different objects.
	 
	 list1.add(o5)                       // true
	 list1                               // [[TestEquatableObject o1],[TestEquatableObject o1]]
	 
	 o1.equals(o5)                       // true
	 o1.equals("abc")                    // false
	 
	 var list2:ArrayList = new ArrayList();
	 
	 list2.equals(list1)                 // false
	 list2.add(o5)                       // true
	 list1                               // [[TestEquatableObject o1],[TestEquatableObject o1]]
	 list2                               // [[TestEquatableObject o1]]
	 list2.equals(list1)                 // false
	 
	 list2.add(o5)                       // true
	 list1                               // [[TestEquatableObject o1],[TestEquatableObject o1]]
	 list2                               // [[TestEquatableObject o1],[TestEquatableObject o1]]
	 list2.equals(list1)                 // true
	 
	 list2.remove(o1)                    // true -&gt; equality used
	 list2                               // [[TestEquatableObject o1]]
	 
	 var uniqueList:UniqueList = new UniqueList(new ArrayList());
	 
	 uniqueList.contains(o1)             // false
	 uniqueList.add(o1)                  // true
	 uniqueList                          // [[TestEquatableObject o1]]
	 uniqueList.contains(o1)             // true
	 
	 uniqueList.add(o5)                  // false
	 uniqueList.contains(o5)             // true -&gt; by equality the object o5 is in the list because its 'id' is the same of the object o1.
	 uniqueList                          // [[TestEquatableObject o1]]
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections:AbstractList"/>
                  <Inherit id="org.as3collections:AbstractArrayCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses>
                  <class id="org.as3collections.lists:SortedArrayList"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.xml#AbstractList">
               <linktext>AbstractList</linktext>
            </link>
            <link href="org.as3collections.lists.xml#TypedList">
               <linktext>TypedList</linktext>
            </link>
            <link href="org.as3collections.lists.xml#UniqueList">
               <linktext>UniqueList</linktext>
            </link>
            <link href="org.as3collections.lists.xml#SortedArrayList">
               <linktext>SortedArrayList</linktext>
            </link>
            <link href="org.as3collections.utils.xml#ListUtil/getUniqueList()">
               <linktext>ListUtil.getUniqueList()</linktext>
            </link>
            <link href="org.as3collections.utils.xml#ListUtil/getTypedList()">
               <linktext>ListUtil.getTypedList()</linktext>
            </link>
            <link href="org.as3collections.utils.xml#ListUtil/getUniqueTypedList()">
               <linktext>ListUtil.getUniqueTypedList()</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.lists:TypedSortedList">
         <apiName>TypedSortedList</apiName>
         <shortdesc>
	 TypedSortedList works as a wrapper for a ISortedList object.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="TypedSortedList,org.as3collections.lists.TypedSortedList,comparator,comparator,comparator,modCount,modCount,options,options,options,add,addAll,addAllAt,addAllAt,addAllAt,addAt,addAt,addAt,addAt,addAt,clear,clear,clone,clone,clone,clone,clone,clone,clone,ensureCapacity,equals,equals,equals,equals,equals,getAt,getAt,indexOf,indexOf,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listIterator,listIterator,remove,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,retainAll,reverse,reverse,reverse,reverse,setAt,setAt,setAt,setAt,setAt,sort,sort,sort,sortOn,sortOn,sortOn,subList,subList,subList,subList,subList,subList,subList"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:ISortedList</apiBaseInterface>
               <apiBaseClassifier>org.as3collections.lists:TypedList</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	              <codeph>TypedSortedList</codeph> works as a wrapper for a <codeph>ISortedList</codeph> object.
	 Since ActionScript 3.0 does not support typed arrays, <codeph>TypedSortedList</codeph> is a way to create typed lists.
	 It stores the <codeph>wrapList</codeph> constructor's argument internaly.
	 So every method call to this class is forwarded to the <codeph>wrappedList</codeph> object.
	 The methods that need to be checked for the type of the elements are previously validated before forward the call.
	 If the type of an element requested to be added to this list is incompatible with the type of the list a <codeph>org.as3coreaddendum.errors.ClassCastError</codeph> is thrown.
	 The calls that are forwarded to the <codeph>wrappedList</codeph> returns the return of the <codeph>wrappedList</codeph> call.
	 <p>
                  <codeph>TypedSortedList</codeph> does not allow <codeph>null</codeph> elements.</p>
	              <p>You can also create unique and typed sorted lists.
	 See below the link "ListUtil.getUniqueTypedSortedList()".</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.ISortedList;
	 import org.as3collections.IListIterator;
	 import org.as3collections.lists.SortedArrayList;
	 import org.as3collections.lists.TypedSortedList;
	 import org.as3collections.utils.ListUtil;
	 
	 var l1:ISortedList = new SortedArrayList([3, 5, 7], null, Array.NUMERIC);
	 
	 var list1:ISortedList = new TypedSortedList(l1, int); // you can use this way
	 
	 //var list1:ISortedList = ListUtil.getTypedSortedList(l1, int); // or you can use this way
	 
	 list1                          // [3,5,7]
	 list1.size()                   // 3
	 
	 list1.add(8)                   // true
	 list1                          // [3,5,7,8]
	 list1.size()                   // 4
	 
	 list1.remove("abc")            // false
	 list1                          // [3,4,5,7,8]
	 list1.size()                   // 5
	 
	 var it:IListIterator = list1.listIterator();
	 var e:int;
	 
	 while (it.hasNext())
	 {
	 
	     e = it.next()
	     e                          // 3
	 
	     e = it.next()
	     e:                         // 4
	 
	     e = it.next()
	     e                          // 5
	 
	     if (e == 5)
	     {
	         it.add("ghi")          // ClassCastError: Invalid element type. element: ghi | type: String | expected type: int
	     }
	 }
	 
	 list1.setAt(0, [1,2])          // ClassCastError: Invalid element type. element: 1,2 | type: Array | expected type: int
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections.lists:TypedList"/>
                  <Inherit id="org.as3collections:TypedCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:ISortedList"/>
               </Implements>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.utils.xml#ListUtil/getTypedSortedList()">
               <linktext>ListUtil.getTypedSortedList()</linktext>
            </link>
            <link href="org.as3collections.utils.xml#ListUtil/getUniqueTypedSortedList()">
               <linktext>ListUtil.getUniqueTypedSortedList()</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.lists:SortedArrayList">
         <apiName>SortedArrayList</apiName>
         <shortdesc>
	 A list that provides a total ordering on its elements.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="SortedArrayList,org.as3collections.lists.SortedArrayList,comparator,comparator,comparator,modCount,modCount,options,options,options,add,addAll,addAllAt,addAllAt,addAllAt,addAt,addAt,addAt,addAt,addAt,clear,clear,clone,clone,clone,clone,clone,clone,clone,ensureCapacity,equals,equals,equals,equals,equals,getAt,getAt,indexOf,indexOf,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listIterator,listIterator,remove,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,retainAll,reverse,reverse,reverse,reverse,setAt,setAt,setAt,setAt,setAt,sort,sort,sort,sortOn,sortOn,sortOn,subList,subList,subList,subList,subList,subList,subList"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:ISortedList</apiBaseInterface>
               <apiBaseClassifier>org.as3collections.lists:ArrayList</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 A list that provides a <i>total ordering</i> on its elements.
	 The list is ordered according to the <i>natural ordering</i> of its elements, by a <i>IComparator</i> typically provided at sorted list creation time, or by the arguments provided to the <codeph>sort</codeph> or <codeph>sortOn</codeph> methods.
	 <p>For each change that occurs the list is automatically reordered using <codeph>comparator</codeph> and <codeph>options</codeph>.
	 If none was provided the default behavior of <codeph>sort</codeph> method is used.</p>
	              <p>The user of this list may change their order at any time using the setters <codeph>comparator</codeph> and <codeph>options</codeph>, or by calling <codeph>sort</codeph> or <codeph>sortOn</codeph> methods and imposing other arguments to change the sort behaviour.</p>
	              <p>It's possible to create unique sorted lists, typed sorted lists and even unique typed sorted lists.
	 You just sends the <codeph>SortedArrayList</codeph> object to the wrappers <codeph>UniqueSortedList</codeph> or <codeph>TypedSortedList</codeph> or uses the <codeph>ListUtil.getUniqueSortedList</codeph>, <codeph>ListUtil.getTypedSortedList</codeph> or <codeph>ListUtil.getUniqueTypedSortedList</codeph>.</p>
	              <p>This documentation is partially based in the <i>Java Collections Framework</i> JavaDoc documentation.
	 For further information see <xref href="http://download.oracle.com/javase/6/docs/technotes/guides/collections/index.html"
                        scope="external">Java Collections Framework</xref>
               </p>
	 
	           </apiDesc>
            <example>
	 
	              <b>Example 1</b>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.ISortedList;
	 import org.as3collections.lists.SortedArrayList;
	 
	 var list1:ISortedList = new SortedArrayList([3, 5, 1, 7], null, Array.NUMERIC | Array.DESCENDING);
	 
	 list1                       // [7,5,3,1]
	 list1.size()                // 4
	 
	 list1.addAt(3, 8)           // true
	 list1                       // [8,7,5,3,1]
	 list1.size()                // 5
	 
	 list1.add(4)                // true
	 list1                       // [8,7,5,4,3,1]
	 list1.size()                // 6
	 
	 list1.add(5)                // true
	 list1                       // [8,7,5,5,4,3,1]
	 list1.size()                // 7
	 
	 list1.sort(null, Array.NUMERIC)
	 list1                       // [1,3,4,5,5,7,8]
	 
	 list1.add(2)                // true
	 list1                       // [8,7,5,5,4,3,2,1]
	 list1.size()                // 8
	 
	 list1.reverse()
	 list1                       // [1,2,3,4,5,5,7,8]
	 
	 list1.add(6)                // true
	 list1                       // [1,2,3,4,5,5,6,7,8]
	 
	 list1.add(9)                // true
	 list1                       // [1,2,3,4,5,5,6,7,8,9]
	 
	 list1.reverse()
	 list1                       // [9,8,7,6,5,5,4,3,2,1]
	 
	 list1.add(10)               // true
	 list1                       // [10,9,8,7,6,5,5,4,3,2,1]
	 
	 list1.add(-1)               // true
	 list1                       // [10,9,8,7,6,5,5,4,3,2,1,-1]
	 
	 //list1.add("c")            // TypeError: Error #1034: Falha de coerção de tipo: não é possível converter "c" em Number.
	 </codeblock>
	 
	              <b>Example 2</b>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.ISortedList;
	 import org.as3collections.lists.SortedArrayList;
	 import org.as3coreaddendum.system.comparators.AlphabeticComparator;
	 
	 var comparator:AlphabeticComparator = new AlphabeticComparator(false);
	 var arr:Array = ["c", "a", "d", "b"];
	 var list1:ISortedList = new SortedArrayList(arr, comparator);
	 
	 list1                              // [a,b,c,f]
	 list1.size()                       // 4
	 
	 list1.addAt(1, "x")                // true
	 list1                              // [a,b,c,f,x]
	 list1.size()                       // 5
	 
	 list1.add("d")                     // true
	 list1                              // [a,b,c,d,f,x]
	 list1.size()                       // 6
	 
	 list1.add("d")                     // true
	 list1                              // [a,b,c,d,d,f,x]
	 list1.size()                       // 7
	 
	 list1.sort()
	 list1                              // [a,b,c,d,d,f,x]
	 
	 list1.add(2)                       // true
	 list1                              // [2,a,b,c,d,d,f,x]
	 list1.size()                       // 8
	 </codeblock>
	 
	              <b>Example 3</b>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.ISortedList;
	 import org.as3collections.lists.SortedArrayList;
	 
	 var arr:Array = [5, 1, 100, 10, 99];
	 var list1:ISortedList = new SortedArrayList(arr); // default behavior of the sort method
	 
	 list1                       // [1,10,100,5,99]
	 list1.size()                // 5
	 
	 list1.add(50)               // true
	 list1                       // [1,10,100,5,50,99]
	 list1.size()                // 6
	 
	 list1.sort(null, Array.NUMERIC)
	 list1                       // [1,5,10,50,99,100]
	 
	 list1.add(200)              // true
	 list1                       // [1,10,100,200,5,50,99]
	 list1.size()                // 7
	 </codeblock>
	 
	              <b>Example 4 - Unique Sorted List</b>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.ISortedList;
	 import org.as3collections.lists.SortedArrayList;
	 import org.as3collections.utils.ListUtil;
	 
	 var arr:Array = [5, 1, 100, 10, 99, 5];
	 
	 var l1:ISortedList = new SortedArrayList(arr, null, Array.NUMERIC | Array.DESCENDING);
	 
	 var list1:ISortedList = ListUtil.getUniqueSortedList(l1);  // return type is UniqueSortedList
	 
	 list1                 // [100,99,10,5,1]
	 list1.size()          // 5
	 
	 list1.add(50)         // true
	 list1                 // [100,99,50,10,5,1]
	 list1.size()          // 6
	 
	 list1.add(10)         // false
	 list1                 // [100,99,50,10,5,1]
	 list1.size()          // 6
	 </codeblock>
	 
	              <b>Example 5 - Typed Sorted List</b>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.ISortedList;
	 import org.as3collections.lists.SortedArrayList;
	 import org.as3collections.utils.ListUtil;
	 
	 var arr:Array = [5, 1, 100, 10, 99, 5];
	 
	 var l1:ISortedList = new SortedArrayList(arr, null, Array.NUMERIC | Array.DESCENDING);
	 
	 var list1:ISortedList = ListUtil.getTypedSortedList(l1);  // return type is TypedSortedList
	 
	 list1                 // [100,99,10,5,5,1]
	 list1.size()          // 6
	 
	 list1.add(50)         // true
	 list1                 // [100,99,50,10,5,5,1]
	 list1.size()          // 7
	 
	 list1.add(10)         // true
	 list1                 // [100,99,50,10,10,5,5,1]
	 list1.size()          // 8
	 
	 list1.add("a")        // ClassCastError: Invalid element type. element: a | type: String | expected type: int
	 </codeblock>
	 
	              <b>Example 6 - Unique Typed Sorted List</b>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.ISortedList;
	 import org.as3collections.lists.SortedArrayList;
	 import org.as3collections.utils.ListUtil;
	 
	 var arr:Array = [5, 1, 100, 10, 99, 5];
	 
	 var l1:ISortedList = new SortedArrayList(arr, null, Array.NUMERIC | Array.DESCENDING);
	 
	 var list1:ISortedList = ListUtil.getUniqueTypedSortedList(l1);  // return type is TypedSortedList
	 
	 list1                 // [100,99,10,5,1]
	 list1.size()          // 5
	 
	 list1.add(50)         // true
	 list1                 // [100,99,50,10,5,1]
	 list1.size()          // 6
	 
	 list1.add(10)         // false
	 list1                 // [100,99,50,10,5,1]
	 list1.size()          // 6
	 
	 list1.add("a")        // ClassCastError: Invalid element type. element: a | type: String | expected type: int
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections.lists:ArrayList"/>
                  <Inherit id="org.as3collections:AbstractList"/>
                  <Inherit id="org.as3collections:AbstractArrayCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:ISortedList"/>
               </Implements>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.xml#ISortedList">
               <linktext>ISortedList</linktext>
            </link>
            <link href="org.as3collections.lists.xml#ArrayList">
               <linktext>ArrayList</linktext>
            </link>
            <link href="org.as3collections.lists.xml#TypedSortedList">
               <linktext>TypedSortedList</linktext>
            </link>
            <link href="org.as3collections.lists.xml#UniqueSortedList">
               <linktext>UniqueSortedList</linktext>
            </link>
            <link href="org.as3collections.utils.xml#ListUtil/getUniqueSortedList()">
               <linktext>ListUtil.getUniqueSortedList()</linktext>
            </link>
            <link href="org.as3collections.utils.xml#ListUtil/getTypedSortedList()">
               <linktext>ListUtil.getTypedSortedList()</linktext>
            </link>
            <link href="org.as3collections.utils.xml#ListUtil/getUniqueTypedSortedList()">
               <linktext>ListUtil.getUniqueTypedSortedList()</linktext>
            </link>
         </related-links>
      </apiClassifier>
   </apiPackage>
   <apiPackage id="org.as3collections.maps">
      <apiName>org.as3collections.maps</apiName>
      <apiDetail/>
      <apiClassifier id="org.as3collections.maps:TypedMap">
         <apiName>TypedMap</apiName>
         <shortdesc>
	 TypedMap works as a wrapper for a map.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="TypedMap,org.as3collections.maps.TypedMap,allKeysEquatable,allValuesEquatable,comparator,comparator,modCount,options,options,sortBy,sortBy,typeKeys,typeValues,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,clone,clone,containsKey,containsValue,entryCollection,equals,equals,equals,getKeyAt,getKeys,getValue,getValueAt,getValues,headMap,headMap,indexOfKey,indexOfValue,isEmpty,iterator,iterator,iterator,iterator,iterator,listMapIterator,listMapIterator,put,put,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAt,removeAt,removeRange,removeRange,retainAll,retainAll,retainAll,reverse,setKeyAt,setKeyAt,setKeyAt,setValueAt,setValueAt,setValueAt,size,sort,sort,sortOn,sortOn,subMap,subMap,subMap,subMap,tailMap,tailMap,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IMap</apiBaseInterface>
               <apiBaseClassifier>Object</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	              <codeph>TypedMap</codeph> works as a wrapper for a map.
	 It stores the <codeph>wrapMap</codeph> constructor's argument in the <codeph>wrappedMap</codeph> variable.
	 So every method call to this class is forwarded to the <codeph>wrappedMap</codeph> object.
	 The methods that need to be checked for the type of the keys and values are previously validated with the <codeph>validateKeyType</codeph>, <codeph>validateValueType</codeph> or <codeph>validateMap</codeph> method before forward the call.
	 If the type of a key or value requested to be inserted to this map is incompatible with the type of the map a <codeph>org.as3coreaddendum.errors.ClassCastError</codeph> is thrown.
	 The calls that are forwarded to the <codeph>wrappedMap</codeph> returns the return of the <codeph>wrappedMap</codeph> call.
	 <p>
                  <codeph>TypedMap</codeph> does not allow <codeph>null</codeph> keys or values.</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IMap;
	 import org.as3collections.maps.ArrayListMap;
	 import org.as3collections.maps.TypedMap;
	 
	 var map1:IMap = new ArrayListMap();
	 
	 map1.put("e", 1)            // null
	 map1.put("d", 2)            // null
	 map1.put("c", 3)            // null
	 map1.put("b", 4)            // null
	 map1.put("a", 5)            // null
	 
	 map1                        // {e=1,d=2,c=3,b=4,a=5}
	 map1.size()                 // 5
	 
	 var map2:IMap = new TypedMap(map1, String, Number); // you can use this way
	 
	 //var map2:IMap = MapUtil.getTypedMap(map1, String, Number); // or you can use this way
	 
	 map2                        // {e=1,d=2,c=3,b=4,a=5}
	 map2.size()                 // 5
	 
	 map2.equals(map1)           // false
	 
	 map2.put("f", 6)            // null
	 map2                        // {e=1,d=2,c=3,b=4,a=5,f=6}
	 map2.size()                 // 6
	 
	 map2.put("g", "h")          // ClassCastError: Invalid value type. value: h | type: String | expected value type: Number
	 map2.put(7, 8)              // ClassCastError: Invalid key type. key: 7 | type: int | expected key type: String
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IMap"/>
               </Implements>
               <Subclasses>
                  <class id="org.as3collections.maps:TypedListMap"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.utils.xml#MapUtil/getTypedMap()">
               <linktext>MapUtil.getTypedMap()</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.maps:SortedArrayListMap">
         <apiName>SortedArrayListMap</apiName>
         <shortdesc>
	 A map that provides a total ordering on its mappings.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="SortedArrayListMap,org.as3collections.maps.SortedArrayListMap,allKeysEquatable,allValuesEquatable,comparator,comparator,modCount,options,options,sortBy,sortBy,typeKeys,typeValues,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,clone,clone,containsKey,containsValue,entryCollection,equals,equals,equals,getKeyAt,getKeys,getValue,getValueAt,getValues,headMap,headMap,indexOfKey,indexOfValue,isEmpty,iterator,iterator,iterator,iterator,iterator,listMapIterator,listMapIterator,put,put,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAt,removeAt,removeRange,removeRange,retainAll,retainAll,retainAll,reverse,setKeyAt,setKeyAt,setKeyAt,setValueAt,setValueAt,setValueAt,size,sort,sort,sortOn,sortOn,subMap,subMap,subMap,subMap,tailMap,tailMap,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:ISortedMap</apiBaseInterface>
               <apiBaseClassifier>org.as3collections.maps:ArrayListMap</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 A map that provides a <i>total ordering</i> on its mappings.
	 The map is ordered according to the <i>natural ordering</i> of its keys or values, by a <i>IComparator</i> typically provided at sorted map creation time, or by the arguments provided to the <codeph>sort</codeph> or <codeph>sortOn</codeph> methods.
	 <p>For each change that occurs the map is automatically ordered using the <codeph>comparator</codeph> and <codeph>options</codeph>.
	 If none was provided the default behavior of the <codeph>sort</codeph> method is used.</p>
	 The <codeph>sortBy</codeph> property defines whether the sorting will be made by <codeph>key</codeph> or <codeph>value</codeph>.
	 <p>The user of this map may change their order at any time by calling the <codeph>sort</codeph> or <codeph>sortOn</codeph> method and imposing others arguments to change the sort behaviour.</p>
	              <p>It's possible to create typed sorted maps.
	 You just sends the <codeph>SortedArrayListMap</codeph> object to the wrapper <codeph>TypedSortedMap</codeph> or uses the <codeph>MapUtil.getTypedSortedMap</codeph>.</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.ISortedMap;
	 import org.as3collections.maps.SortedArrayListMap;
	 
	 var map1:ISortedMap = new SortedArrayListMap();
	 
	 map1.put("e", 1)            // null
	 map1.put("d", 2)            // null
	 map1.put("c", 3)            // null
	 map1.put("b", 4)            // null
	 map1.put("a", 5)            // null
	 
	 map1                        // {a=5,b=4,c=3,d=2,e=1}
	 
	 map1.firstKey()             // a
	 map1.lastKey()              // e
	 
	 map1.sortBy = SortMapBy.VALUE;
	 
	 map1                        // {e=1,d=2,c=3,b=4,a=5}
	 
	 map1.firstKey()             // e
	 map1.lastKey()              // a
	 
	 map1.sort(null, Array.NUMERIC);
	 
	 map1                        // {e=1,d=2,c=3,b=4,a=5}
	 
	 map1.sort(null, Array.NUMERIC | Array.DESCENDING);
	 
	 map1                        // {a=5,b=4,c=3,d=2,e=1}
	 
	 map1.sortBy = SortMapBy.KEY;
	 
	 map1                        // {a=5,b=4,c=3,d=2,e=1}
	 
	 map1.headMap("d")           // {a=5,b=4,c=3}
	 map1.tailMap("b")           // {b=4,c=3,d=2,e=1}
	 map1.subMap("b", "d")       // {b=4,c=3}
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections.maps:ArrayListMap"/>
                  <Inherit id="org.as3collections:AbstractListMap"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:ISortedMap"/>
               </Implements>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.utils.xml#MapUtil/getTypedSortedMap()">
               <linktext>MapUtil.getTypedSortedMap()</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.maps:HashMap">
         <apiName>HashMap</apiName>
         <shortdesc>
	 Hash table based implementation of the IMap interface.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="HashMap,org.as3collections.maps.HashMap,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,clone,clone,containsKey,containsValue,entryCollection,equals,equals,equals,getKeyAt,getKeys,getValue,getValueAt,getValues,headMap,headMap,indexOfKey,indexOfValue,isEmpty,iterator,iterator,iterator,iterator,iterator,listMapIterator,listMapIterator,put,put,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAt,removeAt,removeRange,removeRange,retainAll,retainAll,retainAll,reverse,setKeyAt,setKeyAt,setKeyAt,setValueAt,setValueAt,setValueAt,size,sort,sort,sortOn,sortOn,subMap,subMap,subMap,subMap,tailMap,tailMap,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>org.as3collections:AbstractHashMap</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 Hash table based implementation of the <codeph>IMap</codeph> interface.
	 This implementation provides all of the optional map operations, and permits <codeph>null</codeph> values and the <codeph>null</codeph> key.
	 <p>This class makes no guarantees as to the order of the map.
	 In particular, it does not guarantee that the order will remain constant over time.</p>
	              <p>It's possible to create typed maps.
	 You just sends the <codeph>HashMap</codeph> object to the wrapper <codeph>TypedMap</codeph> or uses the <codeph>MapUtil.getTypedMap</codeph>.</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IMap;
	 import org.as3collections.IList;
	 import org.as3collections.maps.HashMap;
	 import org.as3collections.maps.MapEntry;
	 
	 var map1:IMap = new HashMap();
	 var tf1:TextField = new TextField();
	 var tf2:TextField = new TextField();
	 
	 map1                            // {}
	 map1.containsKey("a")           // false
	 map1.containsKey(tf2)           // false
	 map1.containsValue(2)           // false
	 map1.containsValue(tf1)         // false
	 map1.isEmpty()                  // true
	 map1.size()                     // 0
	 
	 map1.put("a", 1)                // null
	 map1                            // {a=1}
	 map1.isEmpty()                  // false
	 map1.size()                     // 1
	 map1.containsKey("a")           // true
	 map1.containsKey(tf2)           // false
	 map1.containsValue(2)           // false
	 map1.containsValue(tf1)         // false
	 
	 map1.put("b", 2)                // null
	 map1                            // {b=2,a=1}
	 map1.isEmpty()                  // false
	 map1.size()                     // 2
	 map1.containsKey("a")           // true
	 map1.containsKey("b")           // true
	 map1.containsKey(tf2)           // false
	 map1.containsValue(2)           // true
	 
	 map1.put("c", 3)                // null
	 map1                            // {b=2,a=1,c=3}
	 map1.size()                     // 3
	 
	 map1.put("tf1", tf1)            // null
	 map1                            // {b=2,a=1,c=3,tf1=[object TextField]}
	 map1.size()                     // 4
	 map1.containsValue(tf1)         // true
	 
	 map1.put(tf2, "tf2")            // null
	 map1                            // {b=2,[object TextField]=tf2,a=1,c=3,tf1=[object TextField]}
	 map1.size()                     // 5
	 map1.containsKey(tf2)           // true
	 
	 map1.put("a", 1.1)              // 1
	 map1                            // {b=2,[object TextField]=tf2,a=1.1,c=3,tf1=[object TextField]}
	 map1.size()                     // 5
	 
	 map1.put("tf1", String)         // [object TextField]
	 map1                            // {b=2,[object TextField]=tf2,a=1.1,c=3,tf1=[class String]}
	 map1.size()                     // 5
	 
	 map1.put(tf2, "tf2.1")          // tf2
	 map1                            // {b=2,[object TextField]=tf2.1,a=1.1,c=3,tf1=[class String]}
	 map1.size()                     // 5
	 
	 map1.put(Number, 999)           // null
	 map1                            // {b=2,[object TextField]=tf2.1,[class Number]=999,a=1.1,c=3,tf1=[class String]}
	 map1.size(): 6
	 
	 map1.getValue("b")              // 2
	 
	 map1.getValue(tf2)              // tf2.1
	 
	 map1.putAllByObject({fa:"fb",ga:"gb",ha:"hb"});
	 
	 map1                            // {b=2,[object TextField]=tf2.1,fa=fb,[class Number]=999,c=3,ha=hb,a=1.1,tf1=[class String],ga=gb}
	 
	 map1.size()                     // 9
	 
	 map1.getValue("fa")             // fb
	 
	 map1.remove("ga")               // gb
	 map1                            // {b=2,[object TextField]=tf2.1,fa=fb,[class Number]=999,c=3,ha=hb,a=1.1,tf1=[class String]}
	 map1.size()                     // 8
	 
	 map1.remove("fa")               // fb
	 map1                            // {b=2,[object TextField]=tf2.1,[class Number]=999,c=3,ha=hb,a=1.1,tf1=[class String]}
	 map1.size()                     // 7
	 
	 map1.remove(tf2)                // tf2.1
	 map1                            // {b=2,[class Number]=999,c=3,ha=hb,a=1.1,tf1=[class String]}
	 map1.size()                     // 6
	 
	 map1.getValue("fa")             // null
	 map1.getValue(tf2)              // null
	 
	 var map2:IMap = map1.clone();
	 
	 map2                            // {b=2,a=1.1,[class Number]=999,c=3,tf1=[class String],ha=hb}
	 map2.size()                     // 6
	 map2.isEmpty()                  // false
	 
	 map1.equals(map2)               // true
	 map2.equals(map1)               // true
	 map2.equals(map2)               // true
	 
	 map2.remove("b")                // 2
	 map2                            // {a=1.1,[class Number]=999,c=3,tf1=[class String],ha=hb}
	 map2.equals(map2)               // true
	 map2.size()                     // 5
	 
	 map1.equals(map2)               // false
	 map2.equals(map1)               // false
	 
	 map2.getValues()                // [1.1,999,3,[class String],hb]
	 
	 var keysMap2:IList = map2.getKeys();
	 
	 keysMap2                        // [a,[class Number],c,tf1,ha]
	 
	 keysMap2.remove("c")            // true
	 keysMap2                        // [a,[class Number],tf1,ha]
	 map2                            // {a=1.1,[class Number]=999,c=3,tf1=[class String],ha=hb}
	 map2.size()                     // 5
	 
	 map2.removeAll(keysMap2)        // true
	 map2                            // {c=3}
	 map2.size()                     // 1
	 map2.isEmpty()                  // false
	 
	 map2.clear();
	 
	 map2                            // {}
	 map2.size()                     // 0
	 map2.isEmpty()                  // true
	 
	 var entry:IMapEntry = new MapEntry("c", 3);
	 
	 entry                           // c=3
	 map2.putEntry(entry)            // null
	 map2                            // {c=3}
	 map2.size()                     // 1
	 
	 map1                            // {b=2,[class Number]=999,c=3,ha=hb,a=1.1,tf1=[class String]}
	 map1.retainAll(map2)            // true
	 map1                            // {c=3}
	 map1.size()                     // 1
	 map1.isEmpty()                  // false
	 
	 map1.put("d", 4)                // null
	 map1.put("e", 5)                // null
	 map1.put("f", 6)                // null
	 
	 map1                            // {c=3,d=4,f=6,e=5}
	 map1.size()                     // 4
	 
	 var it:IIterator = map1.iterator();
	 
	 var e:*;
	 
	 while (it.hasNext())
	 {
	 
	     e = it.next();
	     trace(it.pointer() + "=" + e)    // c=3
	 
	     e = it.next();
	     trace(it.pointer() + "=" + e)    // d=4
	 
	     if (e == 4)
	     {
	         it.remove();
	     }
	 
	     e = it.next();
	     trace(it.pointer() + "=" + e)    // f=6
	 
	     e = it.next();
	     trace(it.pointer() + "=" + e)    // e=5
	 }
	 
	 map1                            // {c=3,f=6,e=5}
	 map1.size()                     // 3
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections:AbstractHashMap"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.utils.xml#MapUtil/getTypedMap()">
               <linktext>MapUtil.getTypedMap()</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.maps:ArrayListMap">
         <apiName>ArrayListMap</apiName>
         <shortdesc>
	 Array based implementation of the IMap interface.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ArrayListMap,org.as3collections.maps.ArrayListMap,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,clone,clone,containsKey,containsValue,entryCollection,equals,equals,equals,getKeyAt,getKeys,getValue,getValueAt,getValues,headMap,headMap,indexOfKey,indexOfValue,isEmpty,iterator,iterator,iterator,iterator,iterator,listMapIterator,listMapIterator,put,put,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAt,removeAt,removeRange,removeRange,retainAll,retainAll,retainAll,reverse,setKeyAt,setKeyAt,setKeyAt,setValueAt,setValueAt,setValueAt,size,sort,sort,sortOn,sortOn,subMap,subMap,subMap,subMap,tailMap,tailMap,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>org.as3collections:AbstractListMap</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 Array based implementation of the <codeph>IMap</codeph> interface.
	 This implementation provides all of the optional map operations, and permits <codeph>null</codeph> values and the <codeph>null</codeph> key.
	 <p>This class makes guarantees as to the order of the map.
	 The order in which elements are stored is the order in which they were inserted.</p>
	              <p>This class has great similarity to <codeph>ArrayList</codeph> class.
	 In a way this class can be thought of as an <codeph>ArrayList</codeph> of mappings.</p>
	              <p>It's possible to create typed list maps.
	 You just sends the <codeph>ArrayListMap</codeph> object to the wrapper <codeph>TypedListMap</codeph> or uses the <codeph>MapUtil.getTypedListMap</codeph>.</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IMap;
	 import org.as3collections.IList;
	 import org.as3collections.maps.ArrayListMap;
	 import org.as3collections.maps.MapEntry;
	 
	 var map1:IMap = new ArrayListMap();
	 var tf1:TextField = new TextField();
	 var tf2:TextField = new TextField();
	 
	 map1                            // {}
	 map1.containsKey("a")           // false
	 map1.containsKey(tf2)           // false
	 map1.containsValue(2)           // false
	 map1.containsValue(tf1)         // false
	 map1.isEmpty()                  // true
	 map1.size()                     // 0
	 
	 map1.put("a", 1)                // null
	 map1                            // {a=1}
	 map1.isEmpty()                  // false
	 map1.size()                     // 1
	 map1.containsKey("a")           // true
	 map1.containsKey(tf2)           // false
	 map1.containsValue(2)           // false
	 map1.containsValue(tf1)         // false
	 
	 map1.put("b", 2)                // null
	 map1                            // {a=1,b=2}
	 map1.isEmpty()                  // false
	 map1.size()                     // 2
	 map1.containsKey("a")           // true
	 map1.containsKey("b")           // true
	 map1.containsKey(tf2)           // false
	 map1.containsValue(2)           // true
	 
	 map1.put("c", 3)                // null
	 map1                            // {a=1,b=2,c=3}
	 map1.size()                     // 3
	 
	 map1.put("tf1", tf1)            // null
	 map1                            // {a=1,b=2,c=3,tf1=[object TextField]}
	 map1.size()                     // 4
	 map1.containsValue(tf1)         // true
	 
	 map1.put(tf2, "tf2")            // null
	 map1                            // {a=1,b=2,c=3,tf1=[object TextField],[object TextField]=tf2}
	 map1.size()                     // 5
	 map1.containsKey(tf2)           // true
	 
	 map1.put("a", 1.1)              // 1
	 map1                            // {a=1.1,b=2,c=3,tf1=[object TextField],[object TextField]=tf2}
	 map1.size()                     // 5
	 
	 map1.put("tf1", String)         // [object TextField]
	 map1                            // {a=1.1,b=2,c=3,tf1=[class String],[object TextField]=tf2}
	 map1.size()                     // 5
	 
	 map1.put(tf2, "tf2.1")          // tf2
	 map1                            // {a=1.1,b=2,c=3,tf1=[class String],[object TextField]=tf2.1}
	 map1.size()                     // 5
	 
	 map1.put(Number, 999)           // null
	 map1                            // {a=1.1,b=2,c=3,tf1=[class String],[object TextField]=tf2.1,[class Number]=999}
	 map1.size()                     // 6
	 
	 map1.getValue("b")              // 2
	 
	 map1.getValue(tf2)              // tf2.1
	 
	 map1.putAllByObject({fa:"fb",ga:"gb",ha:"hb"});
	 
	 map1                            // {a=1.1,b=2,c=3,tf1=[class String],[object TextField]=tf2.1,[class Number]=999,ha=hb,ga=gb,fa=fb}
	 
	 map1.size()                     // 9
	 
	 map1.getValue("fa")             // fb
	 
	 map1.remove("ga")               // gb
	 map1                            // {a=1.1,b=2,c=3,tf1=[class String],[object TextField]=tf2.1,[class Number]=999,ha=hb,fa=fb}
	 map1.size()                     // 8
	 
	 map1.remove("fa")               // fb
	 map1                            // {a=1.1,b=2,c=3,tf1=[class String],[object TextField]=tf2.1,[class Number]=999,ha=hb}
	 map1.size()                     // 7
	 
	 map1.remove(tf2)                // tf2.1
	 map1                            // {a=1.1,b=2,c=3,tf1=[class String],[class Number]=999,ha=hb}
	 map1.size()                     // 6
	 
	 map1.getValue("fa")             // null
	 map1.getValue(tf2)              // null
	 
	 var map2:IMap = map1.clone();
	 
	 map2                            // {a=1.1,b=2,c=3,tf1=[class String],[class Number]=999,ha=hb}
	 map2.size()                     // 6
	 map2.isEmpty()                  // false
	 
	 map1.equals(map2)               // true
	 map2.equals(map1)               // true
	 map2.equals(map2)               // true
	 
	 map2.remove("b")                // 2
	 map2                            // {a=1.1,c=3,tf1=[class String],[class Number]=999,ha=hb}
	 map2.equals(map2)               // true
	 map2.size()                     // 5
	 
	 map1.equals(map2)               // false
	 map2.equals(map1)               // false
	 
	 map2.getValues()                // [1.1,3,[class String],999,hb]
	 
	 var keysMap2:IList = map2.getKeys();
	 
	 keysMap2                        // [a,c,tf1,[class Number],ha]
	 
	 keysMap2.remove("c")            // true
	 keysMap2                        // [a,tf1,[class Number],ha]
	 map2                            // {a=1.1,c=3,tf1=[class String],[class Number]=999,ha=hb}
	 map2.size()                     // 5
	 
	 map2.removeAll(keysMap2)        // true
	 map2                            // {c=3}
	 map2.size()                     // 1
	 map2.isEmpty()                  // false
	 
	 map2.clear();
	 
	 map2                            // {}
	 map2.size()                     // 0
	 map2.isEmpty()                  // true
	 
	 var entry:IMapEntry = new MapEntry("c", 3);
	 
	 entry                           // c=3
	 map2.putEntry(entry)            // null
	 map2                            // {c=3}
	 map2.size()                     // 1
	 
	 map1                            // {a=1.1,b=2,c=3,tf1=[class String],[class Number]=999,ha=hb}
	 map1.retainAll(map2)            // true
	 map1                            // {c=3}
	 map1.size()                     // 1
	 map1.isEmpty()                  // false
	 
	 map1.put("d", 4)                // null
	 map1.put("e", 5)                // null
	 map1.put("f", 6)                // null
	 map1                            // {c=3,d=4,e=5,f=6}
	 map1.size()                     // 4
	 
	 var it:IIterator = map1.iterator();
	 
	 var e:*;
	 
	 while (it.hasNext())
	 {
	 
	     e = it.next();
	     trace(it.pointer() + "=" + e)    // c=3
	 
	     e = it.next();
	     trace(it.pointer() + "=" + e)    // d=4
	 
	     if (e == 4)
	     {
	         it.remove();
	     }
	 
	     e = it.next();
	     trace(it.pointer() + "=" + e)    // e=5
	 
	     e = it.next();
	     trace(it.pointer() + "=" + e)    // f=6
	 }
	 
	 map1                            // {c=3,e=5,f=6}
	 map1.size()                     // 3
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections:AbstractListMap"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses>
                  <class id="org.as3collections.maps:SortedArrayListMap"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.xml#AbstractListMap">
               <linktext>AbstractListMap</linktext>
            </link>
            <link href="org.as3collections.maps.xml#TypedListMap">
               <linktext>TypedListMap</linktext>
            </link>
            <link href="org.as3collections.maps.xml#SortedArrayListMap">
               <linktext>SortedArrayListMap</linktext>
            </link>
            <link href="org.as3collections.utils.xml#MapUtil/getTypedListMap()">
               <linktext>MapUtil.getTypedListMap()</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.maps:ReadOnlyArrayListMap">
         <apiName>ReadOnlyArrayListMap</apiName>
         <shortdesc>
	 An ArrayListMap that doesn't allow modifications.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ReadOnlyArrayListMap,org.as3collections.maps.ReadOnlyArrayListMap,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,clone,clone,containsKey,containsValue,entryCollection,equals,equals,equals,getKeyAt,getKeys,getValue,getValueAt,getValues,headMap,headMap,indexOfKey,indexOfValue,isEmpty,iterator,iterator,iterator,iterator,iterator,listMapIterator,listMapIterator,put,put,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAt,removeAt,removeRange,removeRange,retainAll,retainAll,retainAll,reverse,setKeyAt,setKeyAt,setKeyAt,setValueAt,setValueAt,setValueAt,size,sort,sort,sortOn,sortOn,subMap,subMap,subMap,subMap,tailMap,tailMap,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>org.as3collections:AbstractListMap</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 An <codeph>ArrayListMap</codeph> that doesn't allow modifications.
	 It receives all the mappings by its constructor and can no longer be changed.
	 All methods that change the map will throw an <codeph>UnsupportedOperationError</codeph>.
	 
	 </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IMap;
	 import org.as3collections.maps.ArrayListMap;
	 import org.as3collections.maps.ReadOnlyArrayListMap;
	 
	 var map1:IMap = new ArrayListMap();
	 
	 map1.put("fa", "fb"):     // null
	 map1.put("ga", "gb"):     // null
	 map1.put("ha", "hb"):     // null
	 
	 map1                      // {fa=fb,ga=gb,ha=hb}
	 map1.size()               // 3
	 
	 var map2:IMap = new ReadOnlyArrayListMap(map1);
	 
	 map2                      // {fa=fb,ga=gb,ha=hb}
	 map2.size()               // 3
	 
	 map2.put(1, 2)            // UnsupportedOperationError: ReadOnlyArrayListMap is a read-only map and doesn't allow modifications.
	 
	 map2.remove(1)            // UnsupportedOperationError: ReadOnlyArrayListMap is a read-only map and doesn't allow modifications.
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections:AbstractListMap"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections.maps:TypedSortedMap">
         <apiName>TypedSortedMap</apiName>
         <shortdesc>
	 TypedSortedMap works as a wrapper for a map.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="TypedSortedMap,org.as3collections.maps.TypedSortedMap,allKeysEquatable,allValuesEquatable,comparator,comparator,modCount,options,options,sortBy,sortBy,typeKeys,typeValues,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,clone,clone,containsKey,containsValue,entryCollection,equals,equals,equals,getKeyAt,getKeys,getValue,getValueAt,getValues,headMap,headMap,indexOfKey,indexOfValue,isEmpty,iterator,iterator,iterator,iterator,iterator,listMapIterator,listMapIterator,put,put,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAt,removeAt,removeRange,removeRange,retainAll,retainAll,retainAll,reverse,setKeyAt,setKeyAt,setKeyAt,setValueAt,setValueAt,setValueAt,size,sort,sort,sortOn,sortOn,subMap,subMap,subMap,subMap,tailMap,tailMap,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:ISortedMap</apiBaseInterface>
               <apiBaseClassifier>org.as3collections.maps:TypedListMap</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	              <codeph>TypedSortedMap</codeph> works as a wrapper for a map.
	 It stores the <codeph>wrapMap</codeph> constructor's argument in the <codeph>wrappedMap</codeph> variable.
	 So every method call to this class is forwarded to the <codeph>wrappedMap</codeph> object.
	 The methods that need to be checked for the type of the keys and values are previously validated with the <codeph>validateKeyType</codeph>, <codeph>validateValueType</codeph> or <codeph>validateMap</codeph> method before forward the call.
	 If the type of a key or value requested to be inserted to this map is incompatible with the type of the map a <codeph>org.as3coreaddendum.errors.ClassCastError</codeph> is thrown.
	 The calls that are forwarded to the <codeph>wrappedMap</codeph> returns the return of the <codeph>wrappedMap</codeph> call.
	 <p>
                  <codeph>TypedSortedMap</codeph> does not allow <codeph>null</codeph> keys or values.</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.ISortedMap;
	 import org.as3collections.maps.SortedArrayListMap;
	 import org.as3collections.maps.TypedSortedMap;
	 
	 var map1:ISortedMap = new SortedArrayListMap();
	 
	 map1.put("e", 1)            // null
	 map1.put("d", 2)            // null
	 map1.put("c", 3)            // null
	 map1.put("b", 4)            // null
	 map1.put("a", 5)            // null
	 
	 map1                        // {a=5,b=4,c=3,d=2,e=1}
	 map1.size()                 // 5
	 
	 var map2:ISortedMap = new TypedSortedMap(map1, String, Number); // you can use this way
	 
	 //var map2:ISortedMap = MapUtil.getTypedSortedMap(map1, String, Number); // or you can use this way
	 
	 map2                        // {a=5,b=4,c=3,d=2,e=1}
	 map2.size()                 // 5
	 
	 map2.equals(map1)           // false
	 
	 map2.put("f", 6)            // null
	 map2                        // {a=5,b=4,c=3,d=2,e=1,f=6}
	 map2.size()                 // 6
	 
	 map2.put("g", "h")          // ClassCastError: Invalid value type. value: h | type: String | expected value type: Number
	 map2.put(7, 8)              // ClassCastError: Invalid key type. key: 7 | type: int | expected key type: String
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections.maps:TypedListMap"/>
                  <Inherit id="org.as3collections.maps:TypedMap"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:ISortedMap"/>
               </Implements>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.utils.xml#MapUtil/getTypedSortedMap()">
               <linktext>MapUtil.getTypedSortedMap()</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.maps:TypedListMap">
         <apiName>TypedListMap</apiName>
         <shortdesc>
	 TypedSortedMap works as a wrapper for a map.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="TypedListMap,org.as3collections.maps.TypedListMap,allKeysEquatable,allValuesEquatable,comparator,comparator,modCount,options,options,sortBy,sortBy,typeKeys,typeValues,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,clone,clone,containsKey,containsValue,entryCollection,equals,equals,equals,getKeyAt,getKeys,getValue,getValueAt,getValues,headMap,headMap,indexOfKey,indexOfValue,isEmpty,iterator,iterator,iterator,iterator,iterator,listMapIterator,listMapIterator,put,put,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAt,removeAt,removeRange,removeRange,retainAll,retainAll,retainAll,reverse,setKeyAt,setKeyAt,setKeyAt,setValueAt,setValueAt,setValueAt,size,sort,sort,sortOn,sortOn,subMap,subMap,subMap,subMap,tailMap,tailMap,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IListMap</apiBaseInterface>
               <apiBaseClassifier>org.as3collections.maps:TypedMap</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	              <codeph>TypedSortedMap</codeph> works as a wrapper for a map.
	 It stores the <codeph>wrapMap</codeph> constructor's argument in the <codeph>wrappedMap</codeph> variable.
	 So every method call to this class is forwarded to the <codeph>wrappedMap</codeph> object.
	 The methods that need to be checked for the type of the keys and values are previously validated with the <codeph>validateKeyType</codeph>, <codeph>validateValueType</codeph> or <codeph>validateMap</codeph> method before forward the call.
	 If the type of a key or value requested to be inserted to this map is incompatible with the type of the map a <codeph>org.as3coreaddendum.errors.ClassCastError</codeph> is thrown.
	 The calls that are forwarded to the <codeph>wrappedMap</codeph> returns the return of the <codeph>wrappedMap</codeph> call.
	 <p>
                  <codeph>TypedSortedMap</codeph> does not allow <codeph>null</codeph> keys or values.</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.ISortedMap;
	 import org.as3collections.maps.SortedArrayListMap;
	 import org.as3collections.maps.TypedSortedMap;
	 
	 var map1:ISortedMap = new SortedArrayListMap();
	 
	 map1.put("e", 1)            // null
	 map1.put("d", 2)            // null
	 map1.put("c", 3)            // null
	 map1.put("b", 4)            // null
	 map1.put("a", 5)            // null
	 
	 map1                        // {a=5,b=4,c=3,d=2,e=1}
	 map1.size()                 // 5
	 
	 var map2:ISortedMap = new TypedSortedMap(map1, String, Number); // you can use this way
	 
	 //var map2:ISortedMap = MapUtil.getTypedSortedMap(map1, String, Number); // or you can use this way
	 
	 map2                        // {a=5,b=4,c=3,d=2,e=1}
	 map2.size()                 // 5
	 
	 map2.equals(map1)           // false
	 
	 map2.put("f", 6)            // null
	 map2                        // {a=5,b=4,c=3,d=2,e=1,f=6}
	 map2.size()                 // 6
	 
	 map2.put("g", "h")          // ClassCastError: Invalid value type. value: h | type: String | expected value type: Number
	 map2.put(7, 8)              // ClassCastError: Invalid key type. key: 7 | type: int | expected key type: String
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections.maps:TypedMap"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IListMap"/>
               </Implements>
               <Subclasses>
                  <class id="org.as3collections.maps:TypedSortedMap"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.utils.xml#MapUtil/getTypedSortedMap()">
               <linktext>MapUtil.getTypedSortedMap()</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.maps:ReadOnlyHashMap">
         <apiName>ReadOnlyHashMap</apiName>
         <shortdesc>
	 A HashMap that doesn't allow modifications.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ReadOnlyHashMap,org.as3collections.maps.ReadOnlyHashMap,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,clone,clone,containsKey,containsValue,entryCollection,equals,equals,equals,getKeyAt,getKeys,getValue,getValueAt,getValues,headMap,headMap,indexOfKey,indexOfValue,isEmpty,iterator,iterator,iterator,iterator,iterator,listMapIterator,listMapIterator,put,put,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAt,removeAt,removeRange,removeRange,retainAll,retainAll,retainAll,reverse,setKeyAt,setKeyAt,setKeyAt,setValueAt,setValueAt,setValueAt,size,sort,sort,sortOn,sortOn,subMap,subMap,subMap,subMap,tailMap,tailMap,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>org.as3collections:AbstractHashMap</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 A <codeph>HashMap</codeph> that doesn't allow modifications.
	 It receives all the mappings by its constructor and can no longer be changed.
	 All methods that change the map will throw an <codeph>UnsupportedOperationError</codeph>.
	 
	 </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IMap;
	 import org.as3collections.maps.HashMap;
	 import org.as3collections.maps.ReadOnlyHashMap;
	 
	 var obj:Object = {fa:"fb",ga:"gb",ha:"hb"}
	 
	 var map1:IMap = new HashMap();
	 
	 map1.putAllByObject(obj);
	 
	 map1                  // {ha=hb,ga=gb,fa=fb}
	 map1.size()           // 3
	 
	 var map2:IMap = new ReadOnlyHashMap(map1);
	 
	 map2                  // {ha=hb,ga=gb,fa=fb}
	 map2.size()           // 3
	 
	 map2.put(1, 2)        // UnsupportedOperationError: ReadOnlyHashMap is a read-only map and doesn't allow modifications.
	 
	 map2.remove(1)        // UnsupportedOperationError: ReadOnlyHashMap is a read-only map and doesn't allow modifications.
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections:AbstractHashMap"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
   </apiPackage>
   <apiPackage id="org.as3collections.queues">
      <apiName>org.as3collections.queues</apiName>
      <apiDetail/>
      <apiClassifier id="org.as3collections.queues:TypedQueue">
         <apiName>TypedQueue</apiName>
         <shortdesc>
	 TypedQueue works as a wrapper for a queue.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="TypedQueue,org.as3collections.queues.TypedQueue,add,add,add,add,add,clear,clone,clone,clone,clone,clone,clone,clone,dequeue,dequeue,element,element,equals,equals,equals,iterator,offer,offer,offer,offer,offer,offer,offer,peek,peek,peek,poll,poll,poll,poll,remove,removeAll,sort,sortOn"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IQueue</apiBaseInterface>
               <apiBaseClassifier>org.as3collections:TypedCollection</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	              <codeph>TypedQueue</codeph> works as a wrapper for a queue.
	 Since ActionScript 3.0 does not support typed arrays, <codeph>TypedQueue</codeph> is a way to create typed queues.
	 It stores the <codeph>wrapQueue</codeph> constructor's argument in the <codeph>wrappedQueue</codeph> variable.
	 So every method call to this class is forwarded to the <codeph>wrappedQueue</codeph> object.
	 The methods that need to be checked for the type of the elements are previously validated with the <codeph>validateType</codeph> or <codeph>validateCollection</codeph> method before forward the call.
	 If the type of an element requested to be added to this list is incompatible with the type of the list, the method <codeph>offer</codeph> returns <codeph>false</codeph> and the method <codeph>add</codeph> throws <codeph>org.as3coreaddendum.errors.ClassCastError</codeph>.
	 The calls that are forwarded to the <codeph>wrappedQueue</codeph> returns the return of the <codeph>wrappedQueue</codeph> call.
	 <p>
                  <codeph>TypedQueue</codeph> does not allow <codeph>null</codeph> elements.</p>
	              <p>You can also create unique and typed queues. See below the link "QueueUtil.getUniqueTypedQueue()".</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IQueue;
	 import org.as3collections.queues.LinearQueue;
	 import org.as3collections.queues.TypedQueue;
	 import org.as3collections.utils.QueueUtil;
	 
	 var q1:IQueue = new LinearQueue([1, 5, 3, 7]);
	 
	 var queue1:IQueue = new TypedQueue(q1, int); // you can use this way
	 
	 //var queue1:IQueue = QueueUtil.getTypedQueue(q1); // or you can use this way
	 
	 queue1                      // [1,5,3,7]
	 queue1.size():              // 4
	 queue1.isEmpty()            // false
	 
	 queue1.poll()               // 1
	 queue1                      // [5,3,7]
	 
	 queue1.offer(2)             // true
	 queue1                      // [5,3,7,2]
	 
	 queue1.offer(5)             // true
	 queue1                      // [5,3,7,2,5]
	 
	 queue1.offer("a")           // false
	 queue1                      // [5,3,7,2,5]
	 
	 queue1.add("a")             // ClassCastError: Invalid element type. element: a | type: String | expected type: int
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections:TypedCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IQueue"/>
               </Implements>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.utils.xml#QueueUtil/getTypedQueue()">
               <linktext>QueueUtil.getTypedQueue()</linktext>
            </link>
            <link href="org.as3collections.utils.xml#QueueUtil/getUniqueTypedQueue()">
               <linktext>QueueUtil.getUniqueTypedQueue()</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.queues:UniqueQueue">
         <apiName>UniqueQueue</apiName>
         <shortdesc>
	 UniqueQueue works as a wrapper for a queue.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="UniqueQueue,org.as3collections.queues.UniqueQueue,add,add,add,add,add,clear,clone,clone,clone,clone,clone,clone,clone,dequeue,dequeue,element,element,equals,equals,equals,iterator,offer,offer,offer,offer,offer,offer,offer,peek,peek,peek,poll,poll,poll,poll,remove,removeAll,sort,sortOn"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IQueue</apiBaseInterface>
               <apiBaseClassifier>org.as3collections:UniqueCollection</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	              <codeph>UniqueQueue</codeph> works as a wrapper for a queue.
	 It does not allow duplicated elements in the queue.
	 It stores the <codeph>wrapQueue</codeph> constructor's argument in the <codeph>wrappedQueue</codeph> variable.
	 So every method call to this class is forwarded to the <codeph>wrappedQueue</codeph> object.
	 The methods that need to be checked for duplication are previously validated before forward the call.
	 The calls that are forwarded to the <codeph>wrappedQueue</codeph> returns the return of the <codeph>wrappedQueue</codeph> call.
	 <p>You can also create unique and typed queues. See below the link "QueueUtil.getUniqueTypedQueue()".</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IQueue;
	 import org.as3collections.queues.LinearQueue;
	 import org.as3collections.queues.UniqueQueue;
	 import org.as3collections.utils.QueueUtil;
	 
	 var q1:IQueue = new LinearQueue([1, 5, 3, 7]);
	 
	 var queue1:IQueue = new UniqueQueue(q1); // you can use this way
	 
	 //var queue1:IQueue = QueueUtil.getUniqueQueue(q1); // or you can use this way
	 
	 queue1                      // [1,5,3,7]
	 queue1.size()               // 4
	 queue1.isEmpty()            // false
	 
	 queue1.poll()               // 1
	 queue1                      // [5,3,7]
	 
	 queue1.offer(2)             // true
	 queue1                      // [5,3,7,2]
	 
	 queue1.offer(5)             // false
	 queue1                      // [5,3,7,2]
	 
	 queue1.add(5)               // Error: UniqueQueue is a unique queue and does not allow duplicated elements. Requested element: 5
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections:UniqueCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IQueue"/>
               </Implements>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.utils.xml#QueueUtil/getUniqueQueue()">
               <linktext>QueueUtil.getUniqueQueue()</linktext>
            </link>
            <link href="org.as3collections.utils.xml#QueueUtil/getUniqueTypedQueue()">
               <linktext>QueueUtil.getUniqueTypedQueue()</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.queues:PriorityQueue">
         <apiName>PriorityQueue</apiName>
         <shortdesc>
	 This queue uses a org.as3coreaddendum.system.comparators.PriorityComparator object to sort the elements.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="PriorityQueue,org.as3collections.queues.PriorityQueue,comparator,comparator,comparator,comparator,options,options,options,options,add,add,add,add,add,clear,clone,clone,clone,clone,clone,clone,clone,dequeue,dequeue,element,element,equals,equals,equals,iterator,offer,offer,offer,offer,offer,offer,offer,peek,peek,peek,poll,poll,poll,poll,remove,removeAll,sort,sortOn"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>org.as3collections.queues:SortedQueue</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 This queue uses a <codeph>org.as3coreaddendum.system.comparators.PriorityComparator</codeph> object to sort the elements.
	 All elements must implement the <codeph>org.as3coreaddendum.system.IPriority</codeph> interface, otherwise a <codeph>org.as3coreaddendum.errors.ClassCastError</codeph> is thrown.
	 <p>This queue also adds an event listener on elements to <codeph>org.as3coreaddendum.events.PriorityEvent</codeph> (if elements implement <codeph>flash.events.IEventDispatcher</codeph>).
	 Thus this queue keeps itself automatically sorted if its elements dispatch a <codeph>org.as3coreaddendum.events.PriorityEvent</codeph> when its priority changes.</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 package test
	 {
	     import org.as3coreaddendum.system.IPriority;
	 
	     public class TestPriority extends EventDispatcher implements IPriority
	     {
	         private var _name:String;
	         private var _priority:int;
	 
	         public function get priority(): int { return _priority; }
	 
	         public function set priority(value : int) : void
	         {
	             _priority = value;
	             dispatchEvent(new PriorityEvent(PriorityEvent.CHANGED, _priority));
	         }
	 
	         public function TestPriority(name:String, priority:int)
	         {
	             _name = name;
	             _priority = priority;
	         }
	 
	         public function toString(): String
	         {
	             return "[TestPriority " + _name + "]";
	         }
	     }
	 }
	 </codeblock>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.ISortedQueue;
	 import org.as3collections.queues.PriorityQueue;
	 import test.TestPriority;
	 
	 var queue1:ISortedQueue = new PriorityQueue();
	 
	 var o1:TestPriority = new TestPriority("o1", 1);
	 var o2:TestPriority = new TestPriority("o2", 2);
	 var o3:TestPriority = new TestPriority("o3", 3);
	 var o4:TestPriority = new TestPriority("o4", 4);
	 
	 queue1.offer(o2)            // true
	 queue1                      // [[TestPriority o2]]
	 queue1.size()               // 1
	 
	 queue1.offer(o3)            // true
	 queue1                      // [[TestPriority o3],[TestPriority o2]]
	 queue1.size()               // 2
	 
	 queue1.offer(o2)            // true
	 queue1                      // [[TestPriority o3],[TestPriority o2],[TestPriority o2]]
	 
	 queue1.offer(o1)            // true
	 queue1                      // [[TestPriority o3],[TestPriority o2],[TestPriority o2],[TestPriority o1]]
	 
	 queue1.offer(o4)            // true
	 queue1                      // [[TestPriority o4],[TestPriority o3],[TestPriority o2],[TestPriority o2],[TestPriority o1]]
	 
	 queue1.offer(1)             // false
	 queue1                      // [[TestPriority o4],[TestPriority o3],[TestPriority o2],[TestPriority o2],[TestPriority o1]]
	 
	 queue1.add(1)               // ClassCastError: The element must implement the 'org.as3coreaddendum.system.IPriority' interface. Type received: int
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections.queues:SortedQueue"/>
                  <Inherit id="org.as3collections.queues:LinearQueue"/>
                  <Inherit id="org.as3collections:AbstractQueue"/>
                  <Inherit id="org.as3collections:AbstractArrayCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="http://as3coreaddendum.org/en-us/documentation/asdoc/org/as3coreaddendum/system/IPriority.html">
               <linktext>org.as3coreaddendum.system.IPriority</linktext>
            </link>
            <link href="http://as3coreaddendum.org/en-us/documentation/asdoc/org/as3coreaddendum/events/PriorityEvent.html">
               <linktext>org.as3coreaddendum.events.PriorityEvent</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.queues:LinearQueue">
         <apiName>LinearQueue</apiName>
         <shortdesc>
	 LinearQueue orders elements in a FIFO (first-in-first-out) manner.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="LinearQueue,org.as3collections.queues.LinearQueue,add,add,add,add,add,clear,clone,clone,clone,clone,clone,clone,clone,dequeue,dequeue,element,element,equals,equals,equals,iterator,offer,offer,offer,offer,offer,offer,offer,peek,peek,peek,poll,poll,poll,poll,remove,removeAll,sort,sortOn"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>org.as3collections:AbstractQueue</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	              <codeph>LinearQueue</codeph> orders elements in a FIFO (first-in-first-out) manner.
	 <p>
                  <codeph>LinearQueue</codeph> does not allow <codeph>null</codeph> elements.</p>
	 
	           </apiDesc>
            <example>
	 
	              <b>Example 1</b>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IQueue;
	 import org.as3collections.queues.LinearQueue;
	 
	 var queue:IQueue = new LinearQueue();
	 
	 queue                       // []
	 queue.size()                // 0
	 queue.isEmpty()             // true
	 
	 queue.peek()                // null
	 queue.element()             // NoSuchElementError: The queue is empty.
	 
	 queue.offer(3)              // true
	 queue                       // [3]
	 queue.size()                // 1
	 queue.isEmpty()             // false
	 
	 queue.offer("a")            // true
	 queue                       // [3,a]
	 
	 queue.offer(1)              // true
	 queue                       // [3,a,1]
	 
	 queue.offer(7)              // true
	 queue                       // [3,a,1,7]
	 
	 queue.offer(null)           // false
	 queue.add(null)             // ArgumentError: The 'element' argument must not be 'null'.
	 queue                       // [3,a,1,7]
	 
	 queue.peek()                // 3
	 queue.element()             // 3
	 queue:                      // [3,a,1,7]
	 
	 queue.poll()                // 3
	 queue                       // [a,1,7]
	 
	 queue.dequeue()             // a
	 queue                       // [1,7]
	 
	 queue.remove(10)            // false
	 queue                       // [1,7]
	 
	 queue.remove(7)             // true
	 queue                       // [1]
	 
	 queue.clear()
	 queue                       // []
	 queue.size()                // 0
	 queue.isEmpty()             // true
	 
	 queue.poll()                // null
	 queue.dequeue()             // NoSuchElementError: The queue is empty.
	 </codeblock>
	 
	              <b>Example 2</b>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.IQueue;
	 import org.as3collections.queues.LinearQueue;
	 
	 var queue1:IQueue = new LinearQueue([1, 5, 3, 7]);
	 
	 queue1                      // [1,5,3,7]
	 queue1.size()               // 4
	 queue1.isEmpty()            // false
	 
	 var queue2:IQueue = queue1.clone();
	 
	 queue2                      // [1,5,3,7]
	 queue2.size()               // 4
	 queue2.isEmpty()            // false
	 
	 queue2.equals(queue1)       // true
	 queue1.equals(queue2)       // true
	 
	 queue2.poll()               // 1
	 queue2                      // [5,3,7]
	 
	 queue2.equals(queue1)       // false
	 queue1.equals(queue2)       // false
	 queue2.equals(queue2)       // true
	 
	 queue1.clear()
	 queue1                      // []
	 
	 queue2.clear()
	 queue2:                     // []
	 
	 queue2.equals(queue1)       // true
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections:AbstractQueue"/>
                  <Inherit id="org.as3collections:AbstractArrayCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses>
                  <class id="org.as3collections.queues:SortedQueue"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections.queues:IndexQueue">
         <apiName>IndexQueue</apiName>
         <shortdesc>
	 This queue uses a org.as3coreaddendum.system.comparators.IndexComparator object to sort the elements.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="IndexQueue,org.as3collections.queues.IndexQueue,comparator,comparator,comparator,comparator,options,options,options,options,add,add,add,add,add,clear,clone,clone,clone,clone,clone,clone,clone,dequeue,dequeue,element,element,equals,equals,equals,iterator,offer,offer,offer,offer,offer,offer,offer,peek,peek,peek,poll,poll,poll,poll,remove,removeAll,sort,sortOn"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>org.as3collections.queues:SortedQueue</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 This queue uses a <codeph>org.as3coreaddendum.system.comparators.IndexComparator</codeph> object to sort the elements.
	 All elements must implement the <codeph>org.as3coreaddendum.system.IIndexable</codeph> interface, otherwise a <codeph>org.as3coreaddendum.errors.ClassCastError</codeph> is thrown.
	 <p>This queue also adds an event listener on elements to <codeph>org.as3coreaddendum.events.IndexEvent</codeph> (if elements implement <codeph>flash.events.IEventDispatcher</codeph>).
	 Thus this queue keeps itself automatically sorted if its elements dispatch a <codeph>org.as3coreaddendum.events.IndexEvent</codeph> when its index changes.</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 package test
	 {
	     import org.as3coreaddendum.system.IIndexable;
	 
	     public class TestIndex extends EventDispatcher implements IIndexable
	     {
	         private var _name:String;
	         private var _index:int;
	 
	         public function get index(): int { return _index; }
	 
	         public function set index(value : int) : void
	         {
	             _index = value;
	             dispatchEvent(new IndexEvent(IndexEvent.CHANGED, _index));
	         }
	 
	         public function TestIndex(name:String, index:int)
	         {
	             _name = name;
	             _index = index;
	         }
	 
	         public function toString(): String
	         {
	             return "[TestIndex " + _name + "]";
	         }
	     }
	 }
	 </codeblock>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.ISortedQueue;
	 import org.as3collections.queues.IndexQueue;
	 import test.TestIndex;
	 
	 var queue1:ISortedQueue = new IndexQueue();
	 
	 var o0:TestIndex = new TestIndex("o0", 0);
	 var o1:TestIndex = new TestIndex("o1", 1);
	 var o2:TestIndex = new TestIndex("o2", 2);
	 var o3:TestIndex = new TestIndex("o3", 3);
	 
	 queue1.offer(o1)            // true
	 queue1                      // [[TestIndex o1]]
	 queue1.size()               // 1
	 
	 queue1.offer(o2)            // true
	 queue1                      // [[TestIndex o1],[TestIndex o2]]
	 queue1.size()               // 2
	 
	 queue1.offer(o1)            // true
	 queue1                      // [[TestIndex o1],[TestIndex o1],[TestIndex o2]]
	 
	 queue1.offer(o0)            // true
	 queue1                      // [[TestIndex o0],[TestIndex o1],[TestIndex o1],[TestIndex o2]]
	 
	 queue1.offer(o3)            // true
	 queue1                      // [[TestIndex o0],[TestIndex o1],[TestIndex o1],[TestIndex o2],[TestIndex o3]]
	 
	 queue1.offer(1)             // false
	 queue1                      // [[TestIndex o0],[TestIndex o1],[TestIndex o1],[TestIndex o2],[TestIndex o3]]
	 
	 queue1.add(1)               // ClassCastError: The element must implement the 'org.as3coreaddendum.system.IIndexable' interface. Type received: int
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections.queues:SortedQueue"/>
                  <Inherit id="org.as3collections.queues:LinearQueue"/>
                  <Inherit id="org.as3collections:AbstractQueue"/>
                  <Inherit id="org.as3collections:AbstractArrayCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="http://as3coreaddendum.org/en-us/documentation/asdoc/org/as3coreaddendum/system/IIndexable.html">
               <linktext>org.as3coreaddendum.system.IIndexable</linktext>
            </link>
            <link href="http://as3coreaddendum.org/en-us/documentation/asdoc/org/as3coreaddendum/events/IndexEvent.html">
               <linktext>org.as3coreaddendum.events.IndexEvent</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.queues:PriorityIndexQueue">
         <apiName>PriorityIndexQueue</apiName>
         <shortdesc>
	 This queue uses an org.as3coreaddendum.system.comparators.PriorityIndexComparator object to sort the elements.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="PriorityIndexQueue,org.as3collections.queues.PriorityIndexQueue,comparator,comparator,comparator,comparator,options,options,options,options,add,add,add,add,add,clear,clone,clone,clone,clone,clone,clone,clone,dequeue,dequeue,element,element,equals,equals,equals,iterator,offer,offer,offer,offer,offer,offer,offer,peek,peek,peek,poll,poll,poll,poll,remove,removeAll,sort,sortOn"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>org.as3collections.queues:SortedQueue</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 This queue uses an <codeph>org.as3coreaddendum.system.comparators.PriorityIndexComparator</codeph> object to sort the elements.
	 All elements must implement the <codeph>org.as3coreaddendum.system.IPriority</codeph> and <codeph>org.as3coreaddendum.system.IIndexable</codeph> interfaces, otherwise a <codeph>org.as3coreaddendum.errors.ClassCastError</codeph> is thrown.
	 <p>This queue is useful when you want to sort the objects by priority, but if the priority of two objects are equal, the <codeph>index</codeph> property of the objects are compared to decide wich object comes before.</p>
	              <p>This queue also adds an event listener on elements to <codeph>org.as3coreaddendum.events.PriorityEvent</codeph> and <codeph>org.as3coreaddendum.events.IndexEvent</codeph> (if elements implement <codeph>flash.events.IEventDispatcher</codeph>).
	 Thus this queue keeps itself automatically sorted if its elements dispatch a <codeph>org.as3coreaddendum.events.PriorityEvent</codeph> or <codeph>org.as3coreaddendum.events.IndexEvent</codeph> when its priority or index changes.</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 package test
	 {
	     import org.as3coreaddendum.system.IIndexable;
	     import org.as3coreaddendum.system.IPriority;
	 
	     public class TestIndexablePriority implements IIndexable, IPriority
	     {
	         private var _index:int;
	         private var _name:String;
	         private var _priority:int;
	 
	 
	         public function get priority(): int { return _priority; }
	 
	         public function set priority(value:int): void { _priority = value; }
	 
	         public function get index(): int { return _index; }
	 
	         public function set index(value:int): void { _index = value; }
	 
	         public function TestIndexablePriority(name:String, priority:int, index:int)
	         {
	             _name = name;
	             _priority = priority;
	             _index = index;
	         }
	 
	         public function toString(): String
	         {
	             return "[TestIndexablePriority " + _name + "]";
	         }
	     }
	 }
	 </codeblock>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.ISortedQueue;
	 import org.as3collections.queues.IndexablePriorityQueue;
	 import test.TestIndexablePriority;
	 
	 var queue1:ISortedQueue = new IndexablePriorityQueue();
	 
	 var o1:TestIndexablePriority = new TestIndexablePriority("o1", 1, 0);
	 var o2:TestIndexablePriority = new TestIndexablePriority("o2", 2, 1);
	 var o3:TestIndexablePriority = new TestIndexablePriority("o3", 2, 2);
	 var o4:TestIndexablePriority = new TestIndexablePriority("o4", 4, 3);
	 
	 queue1.offer(o2)            // true
	 queue1                      // [[TestIndexablePriority o2]]
	 queue1.size()               // 1
	 
	 queue1.offer(o3)            // true
	 queue1                      // [[TestIndexablePriority o2],[TestIndexablePriority o3]]
	 queue1.size()               // 2
	 
	 queue1.offer(o2)            // true
	 queue1                      // [[TestIndexablePriority o2],[TestIndexablePriority o2],[TestIndexablePriority o3]]
	 
	 queue1.offer(o1)            // true
	 queue1                      // [[TestIndexablePriority o2],[TestIndexablePriority o2],[TestIndexablePriority o3],[TestIndexablePriority o1]]
	 
	 queue1.offer(o4)            // true
	 queue1                      // [[TestIndexablePriority o4],[TestIndexablePriority o2],[TestIndexablePriority o2],[TestIndexablePriority o3],[TestIndexablePriority o1]]
	 
	 queue1.offer(1)             // false
	 queue1                      // [[TestIndexablePriority o4],[TestIndexablePriority o2],[TestIndexablePriority o2],[TestIndexablePriority o3],[TestIndexablePriority o1]]
	 
	 queue1.add(1)               // ClassCastError: The element must implement the 'org.as3coreaddendum.system.IPriority' interface. Type received: int
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections.queues:SortedQueue"/>
                  <Inherit id="org.as3collections.queues:LinearQueue"/>
                  <Inherit id="org.as3collections:AbstractQueue"/>
                  <Inherit id="org.as3collections:AbstractArrayCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="http://as3coreaddendum.org/en-us/documentation/asdoc/org/as3coreaddendum/system/IPriority.html">
               <linktext>org.as3coreaddendum.system.IPriority</linktext>
            </link>
            <link href="http://as3coreaddendum.org/en-us/documentation/asdoc/org/as3coreaddendum/system/IIndexable.html">
               <linktext>org.as3coreaddendum.system.IIndexable</linktext>
            </link>
            <link href="http://as3coreaddendum.org/en-us/documentation/asdoc/org/as3coreaddendum/events/PriorityEvent.html">
               <linktext>org.as3coreaddendum.events.PriorityEvent</linktext>
            </link>
            <link href="http://as3coreaddendum.org/en-us/documentation/asdoc/org/as3coreaddendum/events/IndexEvent.html">
               <linktext>org.as3coreaddendum.events.IndexEvent</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections.queues:SortedQueue">
         <apiName>SortedQueue</apiName>
         <shortdesc>
	 A queue that provides a total ordering on its elements.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="SortedQueue,org.as3collections.queues.SortedQueue,comparator,comparator,comparator,comparator,options,options,options,options,add,add,add,add,add,clear,clone,clone,clone,clone,clone,clone,clone,dequeue,dequeue,element,element,equals,equals,equals,iterator,offer,offer,offer,offer,offer,offer,offer,peek,peek,peek,poll,poll,poll,poll,remove,removeAll,sort,sortOn"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:ISortedQueue</apiBaseInterface>
               <apiBaseClassifier>org.as3collections.queues:LinearQueue</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 A queue that provides a <i>total ordering</i> on its elements.
	 The queue is ordered according to the <i>natural ordering</i> of its elements, by a <i>IComparator</i> typically provided at sorted queue creation time, or by the arguments provided to the <codeph>sort</codeph> or <codeph>sortOn</codeph> methods.
	 <p>For each change that occurs the queue is automatically ordered using the <codeph>comparator</codeph> and <codeph>options</codeph>.
	 If none was provided the default behavior of the <codeph>sort</codeph> method is used.</p>
	              <p>The user of this queue may change their order at any time by calling the <codeph>sort</codeph> or <codeph>sortOn</codeph> method and imposing others arguments to change the sort behaviour.</p>
	              <p>It's possible to create unique sorted queues, typed sorted queues and even unique typed sorted queues.
	 You just sends the <codeph>SortedQueue</codeph> object to the wrappers <codeph>UniqueQueue</codeph> or <codeph>TypedQueue</codeph> or uses the <codeph>QueueUtil.getUniqueTypedQueue</codeph>.
	 But there's a problem here: the return type will be <codeph>UniqueQueue</codeph> or <codeph>TypedQueue</codeph>.
	 Thus you will can no longer use the <codeph>sort</codeph> and <codeph>sortOn</codeph> methods directly.
	 The wrapped <codeph>SortedQueue</codeph> will be only automatically ordered, with the provided <codeph>comparator</codeph> and <codeph>options</codeph> constructor's arguments.
	 Check the examples at the bottom of the page.</p>
	 
	           </apiDesc>
            <example>
	 
	              <codeblock rev="3.0">
	 import org.as3collections.ISortedQueue;
	 import org.as3collections.queues.SortedQueue;
	 
	 var queue1:ISortedQueue = new SortedQueue([3, 5, 1, 7], null, Array.NUMERIC | Array.DESCENDING);
	 
	 queue1                      // [7,5,3,1]
	 queue1.size()               // 4
	 
	 queue1.add(-1)              // true
	 queue1                      // [7,5,3,1,-1]
	 queue1.size()               // 5
	 
	 queue1.add(4)               // true
	 queue1                      // [7,5,4,3,1,-1]
	 queue1.size()               // 6
	 
	 queue1.add(5)               // true
	 queue1                      // [7,5,5,4,3,1,-1]
	 queue1.size()               // 7
	 
	 queue1.poll()               // 7
	 queue1                      // [5,5,4,3,1,-1]
	 queue1.size()               // 6
	 
	 queue1.sort(null, Array.NUMERIC)
	 queue1                      // [-1,1,3,4,5,5]
	 
	 queue1.poll()               // -1
	 queue1                      // [5,5,4,3,1]
	 queue1.size()               // 5
	 
	 queue1.add(2)               // true
	 queue1                      // [5,5,4,3,2,1]
	 queue1.size()               // 6
	 
	 queue1.add(10)              // true
	 queue1                      // [10,5,5,4,3,2,1]
	 </codeblock>
	 
	           </example>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections.queues:LinearQueue"/>
                  <Inherit id="org.as3collections:AbstractQueue"/>
                  <Inherit id="org.as3collections:AbstractArrayCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:ISortedQueue"/>
               </Implements>
               <Subclasses>
                  <class id="org.as3collections.queues:PriorityQueue"/>
                  <class id="org.as3collections.queues:IndexQueue"/>
                  <class id="org.as3collections.queues:PriorityIndexQueue"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
   </apiPackage>
   <apiPackage id="org.as3collections.utils">
      <apiName>org.as3collections.utils</apiName>
      <apiDetail/>
      <apiClassifier id="org.as3collections.utils:ListUtil">
         <apiName>ListUtil</apiName>
         <shortdesc>
	 A utility class to work with implementations of the IList interface.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ListUtil,org.as3collections.utils.ListUtil,containsDuplication,containsOnlyType,equalConsideringOrder,equalConsideringOrder,equalNotConsideringOrder,equalNotConsideringOrder,feedMapWithXmlList,filterByType,getDuplicate,getTypedList,getTypedListMap,getTypedMap,getTypedQueue,getTypedSortedList,getTypedSortedMap,getUniqueList,getUniqueQueue,getUniqueSortedList,getUniqueTypedList,getUniqueTypedQueue,getUniqueTypedSortedList,maxValue,maxValueIndex,removeAllOccurances,removeDuplicate,shuffle,sortAlphabetically,sortAlphabeticallyByObjectProperty,sortAscending,sortAscendingByObjectProperty,sortDescending,sortDescendingByObjectProperty,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>Object</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 A utility class to work with implementations of the <codeph>IList</codeph> interface.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections.utils:QueueUtil">
         <apiName>QueueUtil</apiName>
         <shortdesc>
	 A utility class to work with implementations of the IQueue interface.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="QueueUtil,org.as3collections.utils.QueueUtil,containsDuplication,containsOnlyType,equalConsideringOrder,equalConsideringOrder,equalNotConsideringOrder,equalNotConsideringOrder,feedMapWithXmlList,filterByType,getDuplicate,getTypedList,getTypedListMap,getTypedMap,getTypedQueue,getTypedSortedList,getTypedSortedMap,getUniqueList,getUniqueQueue,getUniqueSortedList,getUniqueTypedList,getUniqueTypedQueue,getUniqueTypedSortedList,maxValue,maxValueIndex,removeAllOccurances,removeDuplicate,shuffle,sortAlphabetically,sortAlphabeticallyByObjectProperty,sortAscending,sortAscendingByObjectProperty,sortDescending,sortDescendingByObjectProperty,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>Object</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 A utility class to work with implementations of the <codeph>IQueue</codeph> interface.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections.utils:MapUtil">
         <apiName>MapUtil</apiName>
         <shortdesc>
	 A utility class to work with implementations of the IMap interface.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="MapUtil,org.as3collections.utils.MapUtil,containsDuplication,containsOnlyType,equalConsideringOrder,equalConsideringOrder,equalNotConsideringOrder,equalNotConsideringOrder,feedMapWithXmlList,filterByType,getDuplicate,getTypedList,getTypedListMap,getTypedMap,getTypedQueue,getTypedSortedList,getTypedSortedMap,getUniqueList,getUniqueQueue,getUniqueSortedList,getUniqueTypedList,getUniqueTypedQueue,getUniqueTypedSortedList,maxValue,maxValueIndex,removeAllOccurances,removeDuplicate,shuffle,sortAlphabetically,sortAlphabeticallyByObjectProperty,sortAscending,sortAscendingByObjectProperty,sortDescending,sortDescendingByObjectProperty,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>Object</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 A utility class to work with implementations of the <codeph>IMap</codeph> interface.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections.utils:CollectionUtil">
         <apiName>CollectionUtil</apiName>
         <shortdesc>
	 A utility class to work with implementations of the ICollection interface.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="CollectionUtil,org.as3collections.utils.CollectionUtil,containsDuplication,containsOnlyType,equalConsideringOrder,equalConsideringOrder,equalNotConsideringOrder,equalNotConsideringOrder,feedMapWithXmlList,filterByType,getDuplicate,getTypedList,getTypedListMap,getTypedMap,getTypedQueue,getTypedSortedList,getTypedSortedMap,getUniqueList,getUniqueQueue,getUniqueSortedList,getUniqueTypedList,getUniqueTypedQueue,getUniqueTypedSortedList,maxValue,maxValueIndex,removeAllOccurances,removeDuplicate,shuffle,sortAlphabetically,sortAlphabeticallyByObjectProperty,sortAscending,sortAscendingByObjectProperty,sortDescending,sortDescendingByObjectProperty,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>Object</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 A utility class to work with implementations of the <codeph>ICollection</codeph> interface.
	 <p>
                  <codeph>CollectionUtil</codeph> handles <codeph>null</codeph> input collections quietly in almost all methods. When not, it's documented in the method.
	 That is to say that a <codeph>null</codeph> input will not thrown an error in almost all methods.</p>
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
   </apiPackage>
   <apiPackage id="org.as3collections">
      <apiName>org.as3collections</apiName>
      <apiDetail/>
      <apiClassifier id="org.as3collections:AbstractList">
         <apiName>AbstractList</apiName>
         <shortdesc>
	 This class provides a skeletal implementation of the IList interface, to minimize the effort required to implement this interface.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="AbstractList,org.as3collections.AbstractList,KEY,VALUE,allEquatable,allEquatable,allEquatable,allEquatable,allKeysEquatable,allKeysEquatable,allKeysEquatable,allValuesEquatable,allValuesEquatable,allValuesEquatable,key,key,keys,modCount,modCount,modCount,modCount,sortBy,type,value,value,values,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IList</apiBaseInterface>
               <apiBaseClassifier>org.as3collections:AbstractArrayCollection</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 This class provides a skeletal implementation of the <codeph>IList</codeph> interface, to minimize the effort required to implement this interface.
	 <p>This is an abstract class and shouldn't be instantiated directly.</p>
	              <p>The documentation for each non-abstract method in this class describes its implementation in detail.
	 Each of these methods may be overridden if the collection being implemented admits a more efficient implementation.</p>
	              <p>This documentation is partially based in the <i>Java Collections Framework</i> JavaDoc documentation.
	 For further information see <xref href="http://download.oracle.com/javase/6/docs/technotes/guides/collections/index.html"
                        scope="external">Java Collections Framework</xref>
               </p> 
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections:AbstractArrayCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IList"/>
               </Implements>
               <Subclasses>
                  <class id="org.as3collections.lists:ReadOnlyArrayList"/>
                  <class id="org.as3collections.lists:ArrayList"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.xml#IList">
               <linktext>IList</linktext>
            </link>
            <link href="org.as3collections.lists.xml#ArrayList">
               <linktext>ArrayList</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections:TypedCollection">
         <apiName>TypedCollection</apiName>
         <shortdesc>
	 TypedCollection works as a wrapper for a collection.
	 Since ActionScript 3.0 does not support typed arrays, TypedCollection is a way to create typed collections.
	 It stores the wrapCollection constructor's argument internally.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="TypedCollection,org.as3collections.TypedCollection,KEY,VALUE,allEquatable,allEquatable,allEquatable,allEquatable,allKeysEquatable,allKeysEquatable,allKeysEquatable,allValuesEquatable,allValuesEquatable,allValuesEquatable,key,key,keys,modCount,modCount,modCount,modCount,sortBy,type,value,value,values,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:ICollection</apiBaseInterface>
               <apiBaseInterface>org.as3coreaddendum.system:ITypeable</apiBaseInterface>
               <apiBaseClassifier>Object</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	              <p>
                  <codeph>TypedCollection</codeph> works as a wrapper for a collection.</p>
	              <p>Since ActionScript 3.0 does not support typed arrays, <codeph>TypedCollection</codeph> is a way to create typed collections.</p>
	              <p>It stores the <codeph>wrapCollection</codeph> constructor's argument internally.
	 So every method call to this class is forwarded to the <codeph>wrappedCollection</codeph> object.
	 The methods that need to be checked for the type of the elements are previously validated with the <codeph>validateType</codeph> or <codeph>validateCollection</codeph> method before forward the call.
	 If the type of an element requested to be added to this collection is incompatible with the type of the collection a <codeph>org.as3coreaddendum.errors.ClassCastError</codeph> is thrown.
	 The calls that are forwarded to the <codeph>wrappedCollection</codeph> returns the return of the <codeph>wrappedCollection</codeph> call.</p>
	              <p>The <codeph>TypedCollection.type</codeph> setter is not supported and will thrown an <codeph>UnsupportedOperationError</codeph> if used.</p>
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:ICollection"/>
                  <Implement id="org.as3coreaddendum.system:ITypeable"/>
               </Implements>
               <Subclasses>
                  <class id="org.as3collections.lists:TypedList"/>
                  <class id="org.as3collections.queues:TypedQueue"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections:IMapEntry">
         <apiName>IMapEntry</apiName>
         <shortdesc>
	 A map entry (key-value pair).</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="IMapEntry,org.as3collections.IMapEntry,KEY,VALUE,allEquatable,allEquatable,allEquatable,allEquatable,allKeysEquatable,allKeysEquatable,allKeysEquatable,allValuesEquatable,allValuesEquatable,allValuesEquatable,key,key,keys,modCount,modCount,modCount,modCount,sortBy,type,value,value,values"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiInterface/>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3coreaddendum.system:ICloneable</apiBaseInterface>
               <apiBaseInterface>org.as3coreaddendum.system:IEquatable</apiBaseInterface>
               <apiBaseClassifier/>
            </apiClassifierDef>
            <apiDesc>
	 A map entry (key-value pair). The <codeph>IMap.entryList</codeph> method returns a collection-view of the map, whose elements type are of this class.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface>
                  <Interface id="org.as3coreaddendum.system:ICloneable"/>
                  <Interface id="org.as3coreaddendum.system:IEquatable"/>
               </BaseInterface>
               <Inheritance>
                  <Inherit id=""/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3coreaddendum.system:ICloneable"/>
                  <Implement id="org.as3coreaddendum.system:IEquatable"/>
               </Implements>
               <Subclasses/>
               <Implementors>
                  <Implementor id="org.as3collections:MapEntry"/>
               </Implementors>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections:MapEntry">
         <apiName>MapEntry</apiName>
         <shortdesc>
	 An entry maintaining a key and a value.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="MapEntry,org.as3collections.MapEntry,KEY,VALUE,allEquatable,allEquatable,allEquatable,allEquatable,allKeysEquatable,allKeysEquatable,allKeysEquatable,allValuesEquatable,allValuesEquatable,allValuesEquatable,key,key,keys,modCount,modCount,modCount,modCount,sortBy,type,value,value,values,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IMapEntry</apiBaseInterface>
               <apiBaseClassifier>Object</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 An entry maintaining a key and a value.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IMapEntry"/>
               </Implements>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections:IListIterator">
         <apiName>IListIterator</apiName>
         <shortdesc>
	 An iterator for lists that allows the programmer to traverse the list in either direction, modify the list during iteration, and obtain the iterator's current position in the list.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="IListIterator,org.as3collections.IListIterator,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiInterface/>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IIterator</apiBaseInterface>
               <apiBaseClassifier/>
            </apiClassifierDef>
            <apiDesc>
	 An iterator for lists that allows the programmer to traverse the list in either direction, modify the list during iteration, and obtain the iterator's current position in the list.
	 <p>Note that the <codeph>remove</codeph> and <codeph>set</codeph> methods are defined to operate on the last element returned by a call to <codeph>next</codeph> or <codeph>previous</codeph>.</p>
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface>
                  <Interface id="org.as3collections:IIterator"/>
               </BaseInterface>
               <Inheritance>
                  <Inherit id=""/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IIterator"/>
               </Implements>
               <Subclasses/>
               <Implementors>
                  <Implementor id="org.as3collections.iterators:ListIterator"/>
               </Implementors>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections:ISortedMap">
         <apiName>ISortedMap</apiName>
         <shortdesc>
	 A map that provides a total ordering on its mappings, sorting by keys or values.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ISortedMap,org.as3collections.ISortedMap,KEY,VALUE,allEquatable,allEquatable,allEquatable,allEquatable,allKeysEquatable,allKeysEquatable,allKeysEquatable,allValuesEquatable,allValuesEquatable,allValuesEquatable,key,key,keys,modCount,modCount,modCount,modCount,sortBy,type,value,value,values,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiInterface/>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3coreaddendum.system:ISortable</apiBaseInterface>
               <apiBaseInterface>org.as3collections:IListMap</apiBaseInterface>
               <apiBaseClassifier/>
            </apiClassifierDef>
            <apiDesc>
	 A map that provides a <i>total ordering</i> on its mappings, sorting by keys or values.
	 The map is ordered according to the <i>natural ordering</i> of its keys or values, by a <i>IComparator</i> typically provided at sorted map creation time, or by the arguments provided to the <codeph>sort</codeph> or <codeph>sortOn</codeph> methods.
	 The <codeph>sortBy</codeph> property defines whether the sorting will be made by <codeph>key</codeph> or <codeph>value</codeph>.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface>
                  <Interface id="org.as3coreaddendum.system:ISortable"/>
                  <Interface id="org.as3collections:IListMap"/>
                  <Interface id="org.as3collections:IMap"/>
                  <Interface id="org.as3collections:IIterable"/>
                  <Interface id="org.as3coreaddendum.system:ICloneable"/>
                  <Interface id="org.as3coreaddendum.system:IEquatable"/>
               </BaseInterface>
               <Inheritance>
                  <Inherit id=""/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3coreaddendum.system:ISortable"/>
                  <Implement id="org.as3collections:IListMap"/>
               </Implements>
               <Subclasses/>
               <Implementors>
                  <Implementor id="org.as3collections.maps:SortedArrayListMap"/>
                  <Implementor id="org.as3collections.maps:TypedSortedMap"/>
               </Implementors>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections:UniqueCollection">
         <apiName>UniqueCollection</apiName>
         <shortdesc>
	 UniqueCollection works as a wrapper for a collection.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="UniqueCollection,org.as3collections.UniqueCollection,KEY,VALUE,allEquatable,allEquatable,allEquatable,allEquatable,allKeysEquatable,allKeysEquatable,allKeysEquatable,allValuesEquatable,allValuesEquatable,allValuesEquatable,key,key,keys,modCount,modCount,modCount,modCount,sortBy,type,value,value,values,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:ICollection</apiBaseInterface>
               <apiBaseClassifier>Object</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	              <codeph>UniqueCollection</codeph> works as a wrapper for a collection.
	 <p>It does not allow duplicate elements in the collection.</p>
	              <p>It stores the <codeph>wrapCollection</codeph> constructor's argument internally.
	 So every method call to this class is forwarded to the <codeph>wrappedCollection</codeph> object.
	 The methods that need to be checked for duplication are previously validated before forward the call.
	 No error is thrown by the validation of duplication.
	 The calls that are forwarded to the <codeph>wrappedCollection</codeph> returns the return of the <codeph>wrappedCollection</codeph> call.</p>
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:ICollection"/>
               </Implements>
               <Subclasses>
                  <class id="org.as3collections.lists:UniqueList"/>
                  <class id="org.as3collections.queues:UniqueQueue"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections:ISortedQueue">
         <apiName>ISortedQueue</apiName>
         <shortdesc>
	 A queue that provides a total ordering on its elements.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ISortedQueue,org.as3collections.ISortedQueue,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiInterface/>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IQueue</apiBaseInterface>
               <apiBaseInterface>org.as3coreaddendum.system:ISortable</apiBaseInterface>
               <apiBaseClassifier/>
            </apiClassifierDef>
            <apiDesc>
	 A queue that provides a <i>total ordering</i> on its elements.
	 The queue is ordered according to the <i>natural ordering</i> of its elements, by a <i>IComparator</i> typically provided at sorted queue creation time, or by the arguments provided to the <codeph>sort</codeph> or <codeph>sortOn</codeph> methods.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface>
                  <Interface id="org.as3collections:IQueue"/>
                  <Interface id="org.as3coreaddendum.system:ISortable"/>
                  <Interface id="org.as3collections:ICollection"/>
                  <Interface id="org.as3collections:IIterable"/>
                  <Interface id="org.as3coreaddendum.system:ICloneable"/>
                  <Interface id="org.as3coreaddendum.system:IEquatable"/>
               </BaseInterface>
               <Inheritance>
                  <Inherit id=""/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IQueue"/>
                  <Implement id="org.as3coreaddendum.system:ISortable"/>
               </Implements>
               <Subclasses/>
               <Implementors>
                  <Implementor id="org.as3collections.queues:SortedQueue"/>
               </Implementors>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections:IMap">
         <apiName>IMap</apiName>
         <shortdesc>
	 An object that maps keys to values.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="IMap,org.as3collections.IMap,KEY,VALUE,allEquatable,allEquatable,allEquatable,allEquatable,allKeysEquatable,allKeysEquatable,allKeysEquatable,allValuesEquatable,allValuesEquatable,allValuesEquatable,key,key,keys,modCount,modCount,modCount,modCount,sortBy,type,value,value,values,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiInterface/>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IIterable</apiBaseInterface>
               <apiBaseInterface>org.as3coreaddendum.system:ICloneable</apiBaseInterface>
               <apiBaseInterface>org.as3coreaddendum.system:IEquatable</apiBaseInterface>
               <apiBaseClassifier/>
            </apiClassifierDef>
            <apiDesc>
	 An object that maps keys to values.
	 A map cannot contain duplicate keys, each key can map to at most one value.
	 <p>This interface provides three collection views, which allow a map's contents to be viewed as a list of keys, a list of values, or a list of key-value mappings (<codeph>IMapEntry</codeph>).
	 Some map implementations, like the <codeph>ArrayListMap</codeph> class, make specific guarantees as to their order; others, like the <codeph>HashMap</codeph> class, do not.</p>
	              <p>These views, plus <codeph>IMap.iterator()</codeph>, enable various forms of iteration over the keys and values of the map.
	 To iterate over the keys/values the user can use <codeph>IMap.iterator()</codeph> or <codeph>IMap.entryList().iterator()</codeph>.
	 To iterate over the keys the user can use <codeph>IMap.getKeys().iterator()</codeph>.
	 To iterate over the values the user can use <codeph>IMap.getValues().iterator()</codeph>.</p>
	              <p>Some map implementations have restrictions on the keys and values they may contain.
	 For example, some implementations prohibit <codeph>null</codeph> keys and values, and some have restrictions on the types of their keys or values.</p>
	              <p>The methods that modify the map are specified to throw <codeph>org.as3coreaddendum.errors.UnsupportedOperationError</codeph> if the map does not support the operation.
	 These methods are documented as "optional operation".</p>
	              <p>This documentation is partially based in the <i>Java Collections Framework</i> JavaDoc documentation.
	 For further information see <xref href="http://download.oracle.com/javase/6/docs/technotes/guides/collections/index.html"
                        scope="external">Java Collections Framework</xref>
               </p>
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface>
                  <Interface id="org.as3collections:IIterable"/>
                  <Interface id="org.as3coreaddendum.system:ICloneable"/>
                  <Interface id="org.as3coreaddendum.system:IEquatable"/>
               </BaseInterface>
               <Inheritance>
                  <Inherit id=""/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IIterable"/>
                  <Implement id="org.as3coreaddendum.system:ICloneable"/>
                  <Implement id="org.as3coreaddendum.system:IEquatable"/>
               </Implements>
               <Subclasses/>
               <Implementors>
                  <Implementor id="org.as3collections:AbstractHashMap"/>
                  <Implementor id="org.as3collections.maps:TypedMap"/>
               </Implementors>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.xml#AbstractHashMap">
               <linktext>AbstractHashMap</linktext>
            </link>
            <link href="org.as3collections.xml#AbstractListMap">
               <linktext>AbstractListMap</linktext>
            </link>
            <link href="org.as3collections.xml#IMapEntry">
               <linktext>IMapEntry</linktext>
            </link>
            <link href="org.as3collections.xml#IListMap">
               <linktext>IListMap</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections:IIterator">
         <apiName>IIterator</apiName>
         <shortdesc>
	 An iterator over a collection.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="IIterator,org.as3collections.IIterator,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiInterface/>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier/>
            </apiClassifierDef>
            <apiDesc>
	 An iterator over a collection.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id=""/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors>
                  <Implementor id="org.as3collections.iterators:ArrayIterator"/>
                  <Implementor id="org.as3collections.iterators:MapIterator"/>
               </Implementors>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections:IQueue">
         <apiName>IQueue</apiName>
         <shortdesc>
	 A collection designed for holding elements prior to processing.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="IQueue,org.as3collections.IQueue,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiInterface/>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:ICollection</apiBaseInterface>
               <apiBaseClassifier/>
            </apiClassifierDef>
            <apiDesc>
	 A collection designed for holding elements prior to processing.
	 Besides basic <codeph>ICollection</codeph> operations, queues provide additional insertion, extraction, and inspection operations.
	 Each of these methods exists in two forms: one throws an error if the operation fails, the other returns a special value (either <codeph>null</codeph> or <codeph>false</codeph>, depending on the operation).
	 <p>
	                 <adobetable class="innertable">
	 
	 
	 
	 
	                    <tgroup cols="3">
                        <thead>
                           <row>
                              <entry/>
                              <entry>
                                 <i>Throws error</i>
                              </entry>
                              <entry>
                                 <i>Returns special value</i>
                              </entry>
                           </row>
                        </thead>
                        <tbody>
                           <row>
	                             <entry>
                                 <b>Insert</b>
                              </entry>
	                             <entry>
                                 <codeph>add</codeph>
                              </entry>
	                             <entry>
                                 <codeph>offer</codeph>
                              </entry>
	                          </row>
                           <row>
	                             <entry>
                                 <b>Remove</b>
                              </entry>
	                             <entry>
                                 <codeph>dequeue</codeph>
                              </entry>
	                             <entry>
                                 <codeph>poll</codeph>
                              </entry>
	                          </row>
                           <row>
	                             <entry>
                                 <b>Examine</b>
                              </entry>
	                             <entry>
                                 <codeph>element</codeph>
                              </entry>
	                             <entry>
                                 <codeph>peek</codeph>
                              </entry>
	                          </row>
                        </tbody>
                     </tgroup>
                  </adobetable>
	              </p>
	              <p>Queues typically, but do not necessarily, order elements in a FIFO (first-in-first-out) manner.
	 Among the exceptions are priority queues, which order elements according to a supplied comparator, or the elements' natural ordering, and LIFO queues (or stacks) which order the elements LIFO (last-in-first-out).
	 Whatever the ordering used, the head of the queue is that element which would be removed by a call to <codeph>dequeue</codeph> or <codeph>poll</codeph>.
	 In a FIFO queue, all new elements are inserted at the <i>tail</i> of the queue.
	 Other kinds of queues may use different placement rules.
	 Every <codeph>IQueue</codeph> implementation must specify its ordering properties.</p>
	              <p>The <codeph>offer</codeph> method inserts an element if possible, otherwise returning <codeph>false</codeph>.
	 This differs from the <codeph>add</codeph> method, which can fail to add an element only by throwing an error.
	 The <codeph>offer</codeph> method is designed for use when failure is a normal, rather than exceptional occurrence.</p>
	              <p>The <codeph>dequeue</codeph> and <codeph>poll</codeph> methods remove and return the head of the queue.
	 Exactly which element is removed from the queue is a function of the queue's ordering policy, which differs from implementation to implementation.
	 The <codeph>dequeue</codeph> and <codeph>poll</codeph> methods differ only in their behavior when the queue is empty: the <codeph>dequeue</codeph> method throws an error, while the <codeph>poll</codeph> method returns <codeph>null</codeph>.</p> 
	              <p>The <codeph>element</codeph> and <codeph>peek</codeph> methods return, but do not remove, the head of the queue.
	 The <codeph>element</codeph> and <codeph>peek</codeph> methods differ only in their behavior when the queue is empty: the <codeph>element</codeph> method throws an error, while the <codeph>peek</codeph> method returns null.</p>
	              <p>
                  <codeph>IQueue</codeph> implementations generally do not allow insertion of <codeph>null</codeph> elements</p>
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface>
                  <Interface id="org.as3collections:ICollection"/>
                  <Interface id="org.as3collections:IIterable"/>
                  <Interface id="org.as3coreaddendum.system:ICloneable"/>
                  <Interface id="org.as3coreaddendum.system:IEquatable"/>
               </BaseInterface>
               <Inheritance>
                  <Inherit id=""/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:ICollection"/>
               </Implements>
               <Subclasses/>
               <Implementors>
                  <Implementor id="org.as3collections:AbstractQueue"/>
                  <Implementor id="org.as3collections.queues:TypedQueue"/>
                  <Implementor id="org.as3collections.queues:UniqueQueue"/>
               </Implementors>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections:AbstractArrayCollection">
         <apiName>AbstractArrayCollection</apiName>
         <shortdesc>
	 This class provides a skeletal implementation of the ICollection interface, to minimize the effort required to implement this interface.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="AbstractArrayCollection,org.as3collections.AbstractArrayCollection,KEY,VALUE,allEquatable,allEquatable,allEquatable,allEquatable,allKeysEquatable,allKeysEquatable,allKeysEquatable,allValuesEquatable,allValuesEquatable,allValuesEquatable,key,key,keys,modCount,modCount,modCount,modCount,sortBy,type,value,value,values,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:ICollection</apiBaseInterface>
               <apiBaseClassifier>Object</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 This class provides a skeletal implementation of the <codeph>ICollection</codeph> interface, to minimize the effort required to implement this interface. 
	 <p>This is an abstract class and shouldn't be instantiated directly.</p>
	              <p>The documentation for each non-abstract method in this class describes its implementation in detail.
	 Each of these methods may be overridden if the collection being implemented admits a more efficient implementation.</p>
	              <p>This class maintains a native <codeph>Array</codeph> object as its source.</p>
	              <p>
                  <b>IMPORTANT:</b>
               </p>
	              <p>This class implements equality through <codeph>org.as3coreaddendum.system.IEquatable</codeph> interface in the <codeph>equals</codeph> method and in all methods that compares the elements inside this collection (i.e. <codeph>contains</codeph>, <codeph>containsAll</codeph>, <codeph>remove</codeph>, <codeph>removeAll</codeph> and <codeph>retainAll</codeph>).</p>
	              <p>In order to this collection uses the <codeph>equals</codeph> method of its elements in comparisons (rather than default '==' operator), <b>all elements in this collection must implement the</b> 
                  <codeph>org.as3coreaddendum.system.IEquatable</codeph> 
                  <b>interface and also the supplied element.</b>
               </p>
	              <p>For example:</p>
	              <p>myCollection.contains(myElement);</p>
	              <p>All elements inside <codeph>myCollection</codeph>, and <codeph>myElement</codeph>, must implement the <codeph>org.as3coreaddendum.system.IEquatable</codeph> interface so that <codeph>equals</codeph> method of each element can be used in the comparison.
	 Otherwise '==' operator is used.</p>
	              <p>All subclasses of this class <i>must</i> conform with this behavior.</p>
	              <p>This documentation is partially based in the <i>Java Collections Framework</i> JavaDoc documentation.
	 For further information see <xref href="http://download.oracle.com/javase/6/docs/technotes/guides/collections/index.html"
                        scope="external">Java Collections Framework</xref>
               </p>
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:ICollection"/>
               </Implements>
               <Subclasses>
                  <class id="org.as3collections:AbstractList"/>
                  <class id="org.as3collections:AbstractQueue"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.xml#ICollection">
               <linktext>ICollection</linktext>
            </link>
            <link href="org.as3collections.xml#AbstractList">
               <linktext>AbstractList</linktext>
            </link>
            <link href="org.as3collections.xml#AbstractQueue">
               <linktext>AbstractQueue</linktext>
            </link>
            <link href="http://as3coreaddendum.org/en-us/documentation/asdoc/org/as3coreaddendum/system/IEquatable.html">
               <linktext>org.as3coreaddendum.system.IEquatable</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections:SortMapBy">
         <apiName>SortMapBy</apiName>
         <shortdesc>
	 The enumeration class that defines the acceptable values for sort maps by keys or values.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="SortMapBy,org.as3collections.SortMapBy,KEY,VALUE,allEquatable,allEquatable,allEquatable,allEquatable,allKeysEquatable,allKeysEquatable,allKeysEquatable,allValuesEquatable,allValuesEquatable,allValuesEquatable,key,key,keys,modCount,modCount,modCount,modCount,sortBy,type,value,value,values"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier>org.as3coreaddendum.system:Enum</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 The enumeration class that defines the acceptable values for sort maps by keys or values.
	 <p>This is a type-safe enumeration class, which means there is no possibility of creating instances externally.
	 All acceptable values will be created automaticaly by this class internaly, through the constants.</p>
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3coreaddendum.system:Enum"/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections:AbstractListMap">
         <apiName>AbstractListMap</apiName>
         <shortdesc>
	 This class provides a skeletal implementation of the IListMap interface, to minimize the effort required to implement this interface.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="AbstractListMap,org.as3collections.AbstractListMap,KEY,VALUE,allEquatable,allEquatable,allEquatable,allEquatable,allKeysEquatable,allKeysEquatable,allKeysEquatable,allValuesEquatable,allValuesEquatable,allValuesEquatable,key,key,keys,modCount,modCount,modCount,modCount,sortBy,type,value,value,values,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IListMap</apiBaseInterface>
               <apiBaseClassifier>Object</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 This class provides a skeletal implementation of the <codeph>IListMap</codeph> interface, to minimize the effort required to implement this interface.
	 <p>This class maintains two <codeph>ArrayList</codeph> objects as its source, one for <codeph>keys</codeph> and one for <codeph>values</codeph>.</p>
	              <p>This is an abstract class and shouldn't be instantiated directly.</p>
	              <p>This class makes guarantees as to the order of the map.
	 The order in which elements are stored is the order in which they were inserted.</p>
	              <p>The documentation for each non-abstract method in this class describes its implementation in detail.
	 Each of these methods may be overridden if the map being implemented admits a more efficient implementation.</p>
	              <p>
                  <b>IMPORTANT:</b>
               </p>
	              <p>This class implements equality through <codeph>org.as3coreaddendum.system.IEquatable</codeph> interface in the <codeph>equals</codeph> method and in all methods that compares the elements inside this collection (i.e. <codeph>containsKey</codeph>, <codeph>containsValue</codeph>, <codeph>put</codeph>, <codeph>remove</codeph>, <codeph>removeAll</codeph> and <codeph>retainAll</codeph>).</p>
	              <p>In order to this map uses the <codeph>equals</codeph> method of its keys and/or values in comparisons (rather than default '==' operator), <b>all keys and/or values in this map must implement the</b> 
                  <codeph>org.as3coreaddendum.system.IEquatable</codeph> 
                  <b>interface and also the supplied key and/or value.</b>
               </p>
	              <p>For example:</p>
	              <p>myMap.containsKey(myKey);</p>
	              <p>All keys (but in this case only keys) inside <codeph>myMap</codeph>, and <codeph>myKey</codeph>, must implement the <codeph>org.as3coreaddendum.system.IEquatable</codeph> interface so that <codeph>equals</codeph> method of each key can be used in the comparison.
	 Otherwise '==' operator is used. The same is true for values.
	 The use of equality for keys and values are independent.
	 It's possible to use only keys that implement <codeph>IEquatable</codeph>, only values, both, or none.
	 This usage varies according to application needs.</p>
	              <p>All subclasses of this class <i>must</i> conform with this behavior.</p>
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IListMap"/>
               </Implements>
               <Subclasses>
                  <class id="org.as3collections.maps:ArrayListMap"/>
                  <class id="org.as3collections.maps:ReadOnlyArrayListMap"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.xml#IListMap">
               <linktext>IListMap</linktext>
            </link>
            <link href="org.as3collections.xml#IList">
               <linktext>IList</linktext>
            </link>
            <link href="org.as3collections.lists.xml#ArrayList">
               <linktext>ArrayList</linktext>
            </link>
            <link href="http://as3coreaddendum.org/en-us/documentation/asdoc/org/as3coreaddendum/system/IEquatable.html">
               <linktext>org.as3coreaddendum.system.IEquatable</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections:IList">
         <apiName>IList</apiName>
         <shortdesc>
	 An ordered collection.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="IList,org.as3collections.IList,KEY,VALUE,allEquatable,allEquatable,allEquatable,allEquatable,allKeysEquatable,allKeysEquatable,allKeysEquatable,allValuesEquatable,allValuesEquatable,allValuesEquatable,key,key,keys,modCount,modCount,modCount,modCount,sortBy,type,value,value,values,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiInterface/>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:ICollection</apiBaseInterface>
               <apiBaseClassifier/>
            </apiClassifierDef>
            <apiDesc>
	 An ordered collection.
	 The user of this interface has precise control over where in the list each element is inserted.
	 The user can access elements by their integer index (position in the list), and search for elements in the list.
	 <p>Lists typically allow duplicate elements and multiple <codeph>null</codeph> elements if they allow <codeph>null</codeph> elements at all.
	 But there are lists that prohibits duplicates and/or <codeph>null</codeph> elements, by throwing runtime errors when the user attempts to insert them.</p>
	              <p>The <codeph>IList</codeph> interface provides the special <codeph>IListIterator</codeph> iterator, that allows element insertion and replacement, and bidirectional access in addition to the normal operations that the <codeph>IIterator</codeph> interface provides.
	 The <codeph>listIterator()</codeph> method is provided to obtain a <codeph>IListIterator</codeph> implementation that may start at a specified position in the list.</p>
	              <p>The methods that modify the list are specified to throw <codeph>org.as3coreaddendum.errors.UnsupportedOperationError</codeph> if the list does not support the operation.
	 These methods are documented as "optional operation".</p>
	              <p>This documentation is partially based in the <i>Java Collections Framework</i> JavaDoc documentation.
	 For further information see <xref href="http://download.oracle.com/javase/6/docs/technotes/guides/collections/index.html"
                        scope="external">Java Collections Framework</xref>
               </p>
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface>
                  <Interface id="org.as3collections:ICollection"/>
                  <Interface id="org.as3collections:IIterable"/>
                  <Interface id="org.as3coreaddendum.system:ICloneable"/>
                  <Interface id="org.as3coreaddendum.system:IEquatable"/>
               </BaseInterface>
               <Inheritance>
                  <Inherit id=""/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:ICollection"/>
               </Implements>
               <Subclasses/>
               <Implementors>
                  <Implementor id="org.as3collections:AbstractList"/>
                  <Implementor id="org.as3collections.lists:TypedList"/>
                  <Implementor id="org.as3collections.lists:UniqueList"/>
               </Implementors>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.xml#AbstractList">
               <linktext>AbstractList</linktext>
            </link>
            <link href="org.as3collections.xml#ICollection">
               <linktext>ICollection</linktext>
            </link>
            <link href="org.as3collections.xml#ISortedList">
               <linktext>ISortedList</linktext>
            </link>
            <link href="org.as3collections.xml#IListIterator">
               <linktext>IListIterator</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections:AbstractQueue">
         <apiName>AbstractQueue</apiName>
         <shortdesc>
	 This class provides skeletal implementations of some IQueue operations.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="AbstractQueue,org.as3collections.AbstractQueue,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IQueue</apiBaseInterface>
               <apiBaseClassifier>org.as3collections:AbstractArrayCollection</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 This class provides skeletal implementations of some <codeph>IQueue</codeph> operations.
	 The implementations in this class are appropriate when the base implementation does not allow <codeph>null</codeph> elements.
	 Methods <codeph>add</codeph>, <codeph>dequeue</codeph>, and <codeph>element</codeph> are based on <codeph>offer</codeph>, <codeph>poll</codeph>, and <codeph>peek</codeph>, respectively but throw errors instead of indicating failure via <codeph>false</codeph> or <codeph>null</codeph> returns. 
	 <p>An <codeph>IQueue</codeph> implementation that extends this class must minimally define a method <codeph>offer</codeph> which does not permit insertion of <codeph>null</codeph> elements, along with methods <codeph>peek</codeph>, <codeph>poll</codeph>, <codeph>ICollection.iterator</codeph> supporting <codeph>IIterator.remove</codeph> and <codeph>clone</codeph>.
	 Typically, additional methods will be overridden as well.
	 If these requirements cannot be met, consider instead subclassing <codeph>AbstractArrayCollection</codeph>.</p>
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="org.as3collections:AbstractArrayCollection"/>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IQueue"/>
               </Implements>
               <Subclasses>
                  <class id="org.as3collections.queues:LinearQueue"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections:IIterable">
         <apiName>IIterable</apiName>
         <shortdesc>
	 Implementing this interface allows an object to be iterable.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="IIterable,org.as3collections.IIterable,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiInterface/>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseClassifier/>
            </apiClassifierDef>
            <apiDesc>
	 Implementing this interface allows an object to be iterable.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id=""/>
               </Inheritance>
               <Implements/>
               <Subclasses/>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.xml#IIterator">
               <linktext>IIterator</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections:IListMapIterator">
         <apiName>IListMapIterator</apiName>
         <shortdesc>
	 An iterator for maps that allows the programmer to traverse the map in either direction, modify the map during iteration, and obtain the iterator's current position in the map.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="IListMapIterator,org.as3collections.IListMapIterator,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiInterface/>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IIterator</apiBaseInterface>
               <apiBaseClassifier/>
            </apiClassifierDef>
            <apiDesc>
	 An iterator for maps that allows the programmer to traverse the map in either direction, modify the map during iteration, and obtain the iterator's current position in the map.
	 <p>Note that the <codeph>remove</codeph> and <codeph>set</codeph> methods are defined to operate on the last mapping returned by a call to <codeph>next</codeph> or <codeph>previous</codeph>.</p>
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface>
                  <Interface id="org.as3collections:IIterator"/>
               </BaseInterface>
               <Inheritance>
                  <Inherit id=""/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IIterator"/>
               </Implements>
               <Subclasses/>
               <Implementors>
                  <Implementor id="org.as3collections.iterators:ListMapIterator"/>
               </Implementors>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
      </apiClassifier>
      <apiClassifier id="org.as3collections:ICollection">
         <apiName>ICollection</apiName>
         <shortdesc>
	 The root interface in the collection hierarchy.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ICollection,org.as3collections.ICollection,KEY,VALUE,allEquatable,allEquatable,allEquatable,allEquatable,allKeysEquatable,allKeysEquatable,allKeysEquatable,allValuesEquatable,allValuesEquatable,allValuesEquatable,key,key,keys,modCount,modCount,modCount,modCount,sortBy,type,value,value,values,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiInterface/>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IIterable</apiBaseInterface>
               <apiBaseInterface>org.as3coreaddendum.system:ICloneable</apiBaseInterface>
               <apiBaseInterface>org.as3coreaddendum.system:IEquatable</apiBaseInterface>
               <apiBaseClassifier/>
            </apiClassifierDef>
            <apiDesc>
	 The root interface in the <i>collection hierarchy</i>.
	 A collection represents a group of objects, known as its <i>elements</i>.
	 <p>Some collections allow duplicate elements and others do not. Some are ordered and others unordered.</p>
	              <p>This interface is typically used to pass collections around and manipulate them where maximum generality is desired.</p>
	              <p>The methods that modify the collection are specified to throw org.as3coreaddendum.errors.UnsupportedOperationError if the collection does not support the operation.
	 These methods are documented as "optional operation".</p>
	              <p>This documentation is partially based in the <i>Java Collections Framework</i> JavaDoc documentation.
	 For further information see <xref href="http://download.oracle.com/javase/6/docs/technotes/guides/collections/index.html"
                        scope="external">Java Collections Framework</xref>
               </p>
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface>
                  <Interface id="org.as3collections:IIterable"/>
                  <Interface id="org.as3coreaddendum.system:ICloneable"/>
                  <Interface id="org.as3coreaddendum.system:IEquatable"/>
               </BaseInterface>
               <Inheritance>
                  <Inherit id=""/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IIterable"/>
                  <Implement id="org.as3coreaddendum.system:ICloneable"/>
                  <Implement id="org.as3coreaddendum.system:IEquatable"/>
               </Implements>
               <Subclasses/>
               <Implementors>
                  <Implementor id="org.as3collections:AbstractArrayCollection"/>
                  <Implementor id="org.as3collections:TypedCollection"/>
                  <Implementor id="org.as3collections:UniqueCollection"/>
               </Implementors>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.xml#AbstractArrayCollection">
               <linktext>AbstractArrayCollection</linktext>
            </link>
            <link href="org.as3collections.xml#IIterable">
               <linktext>IIterable</linktext>
            </link>
            <link href="org.as3collections.xml#IList">
               <linktext>IList</linktext>
            </link>
            <link href="http://as3coreaddendum.org/en-us/documentation/asdoc/org/as3coreaddendum/system/IEquatable.html">
               <linktext>org.as3coreaddendum.system.IEquatable</linktext>
            </link>
            <link href="http://as3coreaddendum.org/en-us/documentation/asdoc/org/as3coreaddendum/system/ICloneable.html">
               <linktext>org.as3coreaddendum.system.ICloneable</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections:IListMap">
         <apiName>IListMap</apiName>
         <shortdesc>
	 An ordered map.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="IListMap,org.as3collections.IListMap,KEY,VALUE,allEquatable,allEquatable,allEquatable,allEquatable,allKeysEquatable,allKeysEquatable,allKeysEquatable,allValuesEquatable,allValuesEquatable,allValuesEquatable,key,key,keys,modCount,modCount,modCount,modCount,sortBy,type,value,value,values,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiInterface/>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IMap</apiBaseInterface>
               <apiBaseClassifier/>
            </apiClassifierDef>
            <apiDesc>
	 An ordered map.
	 The user of this interface has precise control over where in the map each mapping is inserted.
	 The user can access mappings by their integer index (position in the map), and search for mappings in the map.
	 <p>The <codeph>IListMap</codeph> interface provides the special <codeph>IListMapIterator</codeph> iterator, that allows mapping insertion and replacement, and bidirectional access in addition to the normal operations that the <codeph>IIterator</codeph> interface provides.
	 The <codeph>listMapIterator()</codeph> method is provided to obtain a <codeph>IListMapIterator</codeph> implementation that may start at a specified position in the map.</p>
	              <p>This interface has the purpose to, in certain degree, unify <codeph>IList</codeph> and <codeph>IMap</codeph> interfaces.</p>
	              <p>The methods that modify the map are specified to throw <codeph>org.as3coreaddendum.errors.UnsupportedOperationError</codeph> if the map does not support the operation.
	 These methods are documented as "optional operation".</p>
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface>
                  <Interface id="org.as3collections:IMap"/>
                  <Interface id="org.as3collections:IIterable"/>
                  <Interface id="org.as3coreaddendum.system:ICloneable"/>
                  <Interface id="org.as3coreaddendum.system:IEquatable"/>
               </BaseInterface>
               <Inheritance>
                  <Inherit id=""/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IMap"/>
               </Implements>
               <Subclasses/>
               <Implementors>
                  <Implementor id="org.as3collections:AbstractListMap"/>
                  <Implementor id="org.as3collections.maps:TypedListMap"/>
               </Implementors>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.xml#AbstractListMap">
               <linktext>AbstractListMap</linktext>
            </link>
            <link href="org.as3collections.xml#IMap">
               <linktext>IMap</linktext>
            </link>
            <link href="org.as3collections.xml#ISortedMap">
               <linktext>ISortedMap</linktext>
            </link>
            <link href="org.as3collections.xml#IListMapIterator">
               <linktext>IListMapIterator</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections:AbstractHashMap">
         <apiName>AbstractHashMap</apiName>
         <shortdesc>
	 This class provides a skeletal hash table based implementation of the IMap interface, to minimize the effort required to implement this interface.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="AbstractHashMap,org.as3collections.AbstractHashMap,KEY,VALUE,allEquatable,allEquatable,allEquatable,allEquatable,allKeysEquatable,allKeysEquatable,allKeysEquatable,allValuesEquatable,allValuesEquatable,allValuesEquatable,key,key,keys,modCount,modCount,modCount,modCount,sortBy,type,value,value,values,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IMap</apiBaseInterface>
               <apiBaseClassifier>Object</apiBaseClassifier>
            </apiClassifierDef>
            <apiDesc>
	 This class provides a skeletal hash table based implementation of the <codeph>IMap</codeph> interface, to minimize the effort required to implement this interface.
	 <p>This is an abstract class and shouldn't be instantiated directly.</p>
	              <p>This class maintains a native <codeph>flash.utils.Dictionary</codeph> object as its source.</p>
	              <p>This class makes no guarantees as to the order of the map.
	 In particular, it does not guarantee that the order will remain constant over time.</p>
	              <p>The documentation for each non-abstract method in this class describes its implementation in detail.
	 Each of these methods may be overridden if the map being implemented admits a more efficient implementation.</p>
	              <p>
                  <b>IMPORTANT:</b>
               </p>
	              <p>This class implements equality through <codeph>org.as3coreaddendum.system.IEquatable</codeph> interface in the <codeph>equals</codeph> method and in all methods that compares the elements inside this collection (i.e. <codeph>containsKey</codeph>, <codeph>containsValue</codeph>, <codeph>put</codeph>, <codeph>remove</codeph>, <codeph>removeAll</codeph> and <codeph>retainAll</codeph>).</p>
	              <p>In order to this map uses the <codeph>equals</codeph> method of its keys and/or values in comparisons (rather than default '==' operator), <b>all keys and/or values in this map must implement the</b> 
                  <codeph>org.as3coreaddendum.system.IEquatable</codeph> 
                  <b>interface and also the supplied key and/or value.</b>
               </p>
	              <p>For example:</p>
	              <p>myMap.containsKey(myKey);</p>
	              <p>All keys (but in this case only keys) inside <codeph>myMap</codeph>, and <codeph>myKey</codeph>, must implement the <codeph>org.as3coreaddendum.system.IEquatable</codeph> interface so that <codeph>equals</codeph> method of each key can be used in the comparison.
	 Otherwise '==' operator is used. The same is true for values.
	 The use of equality for keys and values are independent.
	 It's possible to use only keys that implement <codeph>IEquatable</codeph>, only values, both, or none.
	 This usage varies according to application needs.</p>
	              <p>All subclasses of this class <i>must</i> conform with this behavior.</p>
	              <p>This documentation is partially based in the <i>Java Collections Framework</i> JavaDoc documentation.
	 For further information see <xref href="http://download.oracle.com/javase/6/docs/technotes/guides/collections/index.html"
                        scope="external">Java Collections Framework</xref>
               </p>
	 
	           </apiDesc>
            <Inheritancelist>
               <BaseInterface/>
               <Inheritance>
                  <Inherit id="Object"/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IMap"/>
               </Implements>
               <Subclasses>
                  <class id="org.as3collections.maps:HashMap"/>
                  <class id="org.as3collections.maps:ReadOnlyHashMap"/>
               </Subclasses>
               <Implementors/>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.xml#IMap">
               <linktext>IMap</linktext>
            </link>
            <link href="" invalidHref="org.as3collections.HashMap.xml">
               <linktext>HashMap</linktext>
            </link>
            <link href="org.as3collections.xml#AbstractListMap">
               <linktext>AbstractListMap</linktext>
            </link>
            <link href="http://as3coreaddendum.org/en-us/documentation/asdoc/org/as3coreaddendum/system/IEquatable.html">
               <linktext>org.as3coreaddendum.system.IEquatable</linktext>
            </link>
         </related-links>
      </apiClassifier>
      <apiClassifier id="org.as3collections:ISortedList">
         <apiName>ISortedList</apiName>
         <shortdesc>
	 A list that provides a total ordering on its elements.</shortdesc>
         <prolog>
            <author>Flávio Silva
	 </author>
            <asMetadata/>
         </prolog>
            <meta name="keywords"
               content="ISortedList,org.as3collections.ISortedList,add,add,add,add,add,add,add,addAll,addAll,addAll,addAll,addAll,addAllAt,addAllAt,addAt,addAt,clear,clear,clear,clear,clear,clear,clear,clone,clone,clone,clone,clone,clone,contains,contains,contains,contains,containsAll,containsAll,containsAll,containsAll,containsKey,containsKey,containsKey,containsValue,containsValue,containsValue,dequeue,dequeue,element,element,entryCollection,entryCollection,entryCollection,equals,equals,equals,equals,equals,equals,equals,equals,getAt,getAt,getKeyAt,getKeyAt,getKeys,getKeys,getKeys,getValue,getValue,getValue,getValueAt,getValueAt,getValues,getValues,getValues,hasNext,hasPrevious,hasPrevious,headMap,headMap,indexOf,indexOf,indexOfKey,indexOfKey,indexOfValue,indexOfValue,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,isEmpty,iterator,iterator,iterator,iterator,iterator,iterator,lastIndexOf,lastIndexOf,listIterator,listIterator,listMapIterator,listMapIterator,next,nextIndex,nextIndex,offer,offer,peek,peek,pointer,poll,poll,previous,previous,previousIndex,previousIndex,put,put,put,put,putAll,putAll,putAll,putAllAt,putAllAt,putAllByObject,putAllByObject,putAllByObject,putAt,putAt,putEntry,putEntry,putEntry,remove,remove,remove,remove,remove,remove,remove,remove,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAll,removeAt,removeAt,removeAt,removeAt,removeRange,removeRange,removeRange,removeRange,reset,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,retainAll,reverse,reverse,reverse,reverse,set,set,setAt,setAt,setKeyAt,setKeyAt,setValueAt,setValueAt,size,size,size,size,size,size,size,sortOn,sortOn,sortOn,subList,subList,subMap,subMap,tailMap,tailMap,toArray,toArray,toArray,toArray,toString,toString,toString,toString,toString,toString"/>
         <apiClassifierDetail>
            <apiClassifierDef>
               <apiInterface/>
               <apiAccess value="public"/>
               <apiStatic/>
               <apiBaseInterface>org.as3collections:IList</apiBaseInterface>
               <apiBaseInterface>org.as3coreaddendum.system:ISortable</apiBaseInterface>
               <apiBaseClassifier/>
            </apiClassifierDef>
            <apiDesc>
	 A list that provides a <i>total ordering</i> on its elements.
	 The list is ordered according to the <i>natural ordering</i> of its elements, by a <codeph>IComparator</codeph> typically provided at sorted list creation time, or by the arguments provided to the <codeph>sort</codeph> or <codeph>sortOn</codeph> methods.
	 
	 </apiDesc>
            <Inheritancelist>
               <BaseInterface>
                  <Interface id="org.as3collections:IList"/>
                  <Interface id="org.as3coreaddendum.system:ISortable"/>
                  <Interface id="org.as3collections:ICollection"/>
                  <Interface id="org.as3collections:IIterable"/>
                  <Interface id="org.as3coreaddendum.system:ICloneable"/>
                  <Interface id="org.as3coreaddendum.system:IEquatable"/>
               </BaseInterface>
               <Inheritance>
                  <Inherit id=""/>
               </Inheritance>
               <Implements>
                  <Implement id="org.as3collections:IList"/>
                  <Implement id="org.as3coreaddendum.system:ISortable"/>
               </Implements>
               <Subclasses/>
               <Implementors>
                  <Implementor id="org.as3collections.lists:SortedArrayList"/>
                  <Implementor id="org.as3collections.lists:TypedSortedList"/>
                  <Implementor id="org.as3collections.lists:UniqueSortedList"/>
               </Implementors>
               <Excludes/>
            </Inheritancelist>
         </apiClassifierDetail>
         <related-links>
            <link href="org.as3collections.lists.xml#SortedArrayList">
               <linktext>SortedArrayList</linktext>
            </link>
            <link href="http://as3coreaddendum.org/en-us/documentation/asdoc/org/as3coreaddendum/system/ISortable.html">
               <linktext>org.as3coreaddendum.system.ISortable</linktext>
            </link>
         </related-links>
      </apiClassifier>
   </apiPackage>
</allClasses>